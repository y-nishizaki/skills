---
name: "malware-analysis"
description: >
  マルウェア解析の技術を支援します。静的解析・動的解析、Sandbox環境構築、逆アセンブル、
  デバッギング、IoC抽出、マルウェアファミリーの識別など、マルウェアの調査と対策に使用します。
  キーワード - マルウェア、解析、静的解析、動的解析、逆アセンブル、Sandbox、デバッガ、
  IoC。
version: 1.0.0
---

# マルウェア解析スキル

## 目的

このスキルは、マルウェアの解析技術と方法論を提供します。静的解析、動的解析、
コード逆アセンブル、デバッギング、Sandbox環境での実行分析など、
マルウェアの挙動理解と対策立案に必要な実践的知識を含みます。

## このスキルを使用する場合

- マルウェアの解析や調査を求めた場合
- 静的解析・動的解析の手法を知りたい場合
- Sandbox環境の構築を必要とする場合
- IoC（Indicators of Compromise）の抽出を求めた場合
- マルウェアファミリーの識別が必要な場合

## マルウェア解析の基礎

### 解析アプローチ

**1. 静的解析（Static Analysis）**
- マルウェアを実行せずに分析
- ファイル構造、文字列、APIコール、コードフロー
- 安全だが、難読化やパッキングに弱い

**2. 動的解析（Dynamic Analysis）**
- 制御された環境でマルウェアを実行
- 実際の挙動、ネットワーク通信、ファイル操作
- リスクがあるが、実際の動作を観察可能

**3. ハイブリッド解析**
- 静的解析と動的解析を組み合わせ
- 最も効果的なアプローチ

## 静的解析

### ファイル情報取得

```bash
# ファイルタイプ確認
file suspicious_file.exe

# ハッシュ値計算
md5sum suspicious_file.exe
sha256sum suspicious_file.exe

# エントロピー計算（パッキング検出）
python -c "import math; from collections import Counter; data=open('suspicious_file.exe','rb').read(); ent=-sum(p*math.log2(p) for p in (Counter(data).values())); print(f'Entropy: {ent/len(data):.2f}')"

# PEファイル情報（Windows）
pefile suspicious_file.exe
```

Python PEファイル解析:

```python
import pefile
import hashlib

def analyze_pe(filename):
    pe = pefile.PE(filename)

    # 基本情報
    info = {
        'md5': hashlib.md5(open(filename, 'rb').read()).hexdigest(),
        'sha256': hashlib.sha256(open(filename, 'rb').read()).hexdigest(),
        'compile_time': pe.FILE_HEADER.TimeDateStamp,
        'sections': []
    }

    # セクション情報
    for section in pe.sections:
        info['sections'].append({
            'name': section.Name.decode().rstrip('\x00'),
            'virtual_size': section.Misc_VirtualSize,
            'virtual_address': hex(section.VirtualAddress),
            'raw_size': section.SizeOfRawData,
            'entropy': section.get_entropy()
        })

    # インポート関数
    if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT'):
        info['imports'] = []
        for entry in pe.DIRECTORY_ENTRY_IMPORT:
            dll = entry.dll.decode()
            for imp in entry.imports:
                info['imports'].append({
                    'dll': dll,
                    'function': imp.name.decode() if imp.name else f'Ordinal {imp.ordinal}'
                })

    return info

result = analyze_pe('suspicious.exe')
print(f"MD5: {result['md5']}")
print(f"Sections: {len(result['sections'])}")
```

### 文字列抽出

```bash
# ASCII文字列
strings suspicious_file.exe

# Unicode文字列
strings -e l suspicious_file.exe

# 最小長指定
strings -n 10 suspicious_file.exe | grep -E "(http|ftp|\.exe|\.dll)"

# FLOSS（難読化文字列も抽出）
floss suspicious_file.exe
```

### アンパッキング

一般的なパッカー:
- UPX
- Themida
- VMProtect
- ASPack

UPXアンパッキング:

```bash
# UPX検出
upx -t suspicious.exe

# アンパック
upx -d suspicious.exe -o unpacked.exe
```

## 動的解析

### Sandbox環境

推奨ツール:
- **Cuckoo Sandbox**: オープンソース自動解析
- **ANY.RUN**: インタラクティブSandbox
- **Joe Sandbox**: 商用Sandbox
- **VirusTotal**: マルチエンジンスキャン

Cuckoo Sandbox実行:

```bash
# サンプル投入
cuckoo submit suspicious.exe

# レポート取得
cuckoo report TASK_ID --format json
```

### プロセス監視

**Windows - Process Monitor (Procmon):**
- ファイルシステム操作
- レジストリ操作
- ネットワーク活動
- プロセス/スレッド活動

**Process Hacker:**
- プロセス一覧
- メモリダンプ
- ハンドル/DLL
- ネットワーク接続

**Linux - strace/ltrace:**

```bash
# システムコール監視
strace -f -e trace=open,close,read,write ./malware

# ライブラリコール監視
ltrace ./malware
```

### ネットワーク監視

```bash
# Wireshark キャプチャ
tshark -i eth0 -w capture.pcap

# 特定のホストへの通信
tcpdump -i eth0 host 192.168.1.100 -w capture.pcap

# HTTP/HTTPSトラフィック
mitmproxy -w capture
```

インバウンド・ボックス:

```bash
# FakeDNS
python fakedns.py

# INetSim（偽インターネットシミュレータ）
inetsim
```

### レジストリ監視（Windows）

```powershell
# レジストリ変更監視
regshot  # ビフォア/アフタースナップショット比較

# PowerShell監視
Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Run"
```

## 逆アセンブルとデバッグ

### 逆アセンブルツール

**IDA Pro / IDA Free:**
- 業界標準
- インタラクティブディスアセンブラ
- 高度な制御フロー分析

**Ghidra:**
- NSA開発、オープンソース
- デコンパイラ内蔵
- スクリプティング対応

**Radare2:**
- オープンソース
- コマンドライン
- バイナリ分析フレームワーク

Ghidra スクリプト例（Python）:

```python
from ghidra.app.decompiler import DecompInterface
from ghidra.util.task import ConsoleTaskMonitor

# デコンパイラ初期化
decompiler = DecompInterface()
decompiler.openProgram(currentProgram)

# 関数一覧
fm = currentProgram.getFunctionManager()
for func in fm.getFunctions(True):
    # デコンパイル
    result = decompiler.decompileFunction(func, 30, ConsoleTaskMonitor())
    if result.decompileCompleted():
        print(f"Function: {func.getName()}")
        print(result.getDecompiledFunction().getC())
```

### デバッガ

**x64dbg / x32dbg:**
- Windows用デバッガ
- ユーザーフレンドリー
- プラグイン対応

**WinDbg:**
- Microsoft公式
- カーネルデバッグ対応
- 強力だが学習曲線が急

**GDB (Linux):**

```bash
# GDB起動
gdb ./malware

# ブレークポイント設定
break main
break *0x08048484

# 実行
run

# ステップ実行
step  # 関数内に入る
next  # 関数をスキップ

# レジスタ表示
info registers

# メモリダンプ
x/20x $esp

# 逆アセンブル
disassemble main
```

Python デバッガスクリプト（pwndbg）:

```python
import gdb

class MalwareBreakpoint(gdb.Breakpoint):
    def stop(self):
        # ブレークポイントヒット時
        print(f"[*] Hit breakpoint at {hex(self.location)}")

        # レジスタダンプ
        for reg in ['rax', 'rbx', 'rcx', 'rdx']:
            value = gdb.parse_and_eval(f"${reg}")
            print(f"{reg}: {hex(int(value))}")

        return True  # 実行停止

# 特定アドレスにブレークポイント
MalwareBreakpoint("*0x400500")

# 実行
gdb.execute("run")
```

## IoC抽出

### IoC（Indicators of Compromise）

**ファイルベースIoC:**
- MD5/SHA1/SHA256ハッシュ
- ファイル名、パス
- ファイルサイズ

**ネットワークIoC:**
- IPアドレス
- ドメイン名
- URL
- ポート番号

**ホストベースIoC:**
- レジストリキー
- Mutex名
- サービス名
- プロセス名

自動IoC抽出:

```python
import re
import yara

def extract_iocs(malware_path):
    iocs = {
        'ips': [],
        'domains': [],
        'urls': [],
        'emails': [],
        'md5': [],
        'mutex': []
    }

    data = open(malware_path, 'rb').read()
    text = data.decode('latin-1', errors='ignore')

    # IP抽出
    ips = re.findall(r'\b(?:[0-9]{1,3}\.){3}[0-9]{1,3}\b', text)
    iocs['ips'] = list(set(ips))

    # ドメイン抽出
    domains = re.findall(r'\b[a-z0-9]+(?:[-.][a-z0-9]+)*\.[a-z]{2,}\b', text, re.I)
    iocs['domains'] = list(set(domains))

    # URL抽出
    urls = re.findall(r'https?://[^\s]+', text)
    iocs['urls'] = list(set(urls))

    # Email抽出
    emails = re.findall(r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b', text)
    iocs['emails'] = list(set(emails))

    return iocs

iocs = extract_iocs('suspicious.exe')
print(f"Found {len(iocs['ips'])} IP addresses")
print(f"Found {len(iocs['domains'])} domains")
```

## YARA ルール

マルウェア検出シグネチャ:

```yara
rule Emotet_Dropper {
    meta:
        description = "Detects Emotet dropper"
        author = "Security Team"
        date = "2024-01-01"

    strings:
        $api1 = "InternetOpenA" ascii
        $api2 = "InternetReadFile" ascii
        $api3 = "CreateProcessA" ascii
        $string1 = "http://" wide ascii
        $string2 = ".exe" wide ascii

    condition:
        uint16(0) == 0x5A4D and  // MZ header
        all of ($api*) and
        all of ($string*)
}
```

YARAスキャン:

```bash
# スキャン実行
yara rules.yar suspicious_directory/

# 再帰的スキャン
yara -r rules.yar /path/to/scan/

# メタデータ表示
yara -m rules.yar file.exe
```

Python YARA:

```python
import yara

rules = yara.compile(filepath='malware_rules.yar')

matches = rules.match('suspicious.exe')
for match in matches:
    print(f"Rule: {match.rule}")
    print(f"Tags: {match.tags}")
    print(f"Strings: {match.strings}")
```

## マルウェアファミリー識別

### 一般的なマルウェアファミリー

**ランサムウェア:**
- WannaCry
- Ryuk
- LockBit
- Conti

**バンキング型トロイの木馬:**
- Emotet
- TrickBot
- Dridex
- Qakbot

**RAT (Remote Access Trojan):**
- njRAT
- Gh0st RAT
- DarkComet
- AsyncRAT

**インフォスティーラー:**
- Agent Tesla
- Formbook
- Raccoon Stealer
- RedLine

### 機械学習による分類

```python
from sklearn.ensemble import RandomForestClassifier
import numpy as np

class MalwareClassifier:
    def __init__(self):
        self.clf = RandomForestClassifier(n_estimators=100)

    def extract_features(self, pe_file):
        """PE ファイルから特徴抽出"""
        features = []

        # セクション数
        features.append(len(pe_file.sections))

        # エントロピー平均
        avg_entropy = np.mean([s.get_entropy() for s in pe_file.sections])
        features.append(avg_entropy)

        # インポート数
        if hasattr(pe_file, 'DIRECTORY_ENTRY_IMPORT'):
            features.append(len(pe_file.DIRECTORY_ENTRY_IMPORT))
        else:
            features.append(0)

        # ファイルサイズ
        features.append(len(pe_file.__data__))

        return features

    def train(self, X_train, y_train):
        self.clf.fit(X_train, y_train)

    def predict(self, pe_file):
        features = self.extract_features(pe_file)
        return self.clf.predict([features])[0]
```

## 安全な解析環境

### 隔離されたVM環境

推奨構成:
- ホストOS: Linux
- VM: Windows 7/10（スナップショット機能）
- ネットワーク: ホストオンリーまたはNAT（監視下）
- ツール: プリインストール

VMwareスナップショット:

```bash
# スナップショット作成
vmrun snapshot /path/to/vm.vmx clean_state

# スナップショット復元
vmrun revertToSnapshot /path/to/vm.vmx clean_state
```

### REMnux

マルウェア解析用Linuxディストリビューション

主要ツール:
- radare2
- Ghidra
- YARA
- Volatility
- Wireshark

## メモリ分析

### Volatility Framework

```bash
# プロファイル推定
volatility -f memory.dump imageinfo

# プロセス一覧
volatility -f memory.dump --profile=Win7SP1x64 pslist

# 悪意のあるプロセス検出
volatility -f memory.dump --profile=Win7SP1x64 malfind

# ネットワーク接続
volatility -f memory.dump --profile=Win7SP1x64 netscan

# DLL一覧
volatility -f memory.dump --profile=Win7SP1x64 dlllist -p 1234

# プロセスダンプ
volatility -f memory.dump --profile=Win7SP1x64 procdump -p 1234 -D output/

# マルウェア検出
volatility -f memory.dump --profile=Win7SP1x64 yarascan -y malware_rules.yar
```

## ベストプラクティス

1. **安全性第一**
   - 隔離された環境で解析
   - スナップショット利用
   - ネットワーク監視

2. **文書化**
   - すべての手順を記録
   - IoC抽出
   - レポート作成

3. **自動化**
   - 反復タスクのスクリプト化
   - Sandboxの活用
   - YARA ルールの更新

4. **スキル向上**
   - アセンブリ言語の理解
   - OSインターナルズ
   - ネットワークプロトコル

## 参考リソース

- Practical Malware Analysis (書籍)
- Malware Unicorn's Reverse Engineering 101
- SANS FOR610: Reverse Engineering Malware
- OALabs YouTube Channel

## 注意事項

- マルウェアは隔離環境でのみ扱うこと
- 法的リスクの理解
- 倫理的な使用のみ
- バックアップの徹底
