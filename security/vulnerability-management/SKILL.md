---
name: "vulnerability-management"
description: >
  脆弱性管理プロセスを支援します。CVE、NVD、OWASP Top 10の把握と評価、脆弱性スキャン（Nessus、
  OpenVAS、Qualys）、脆弱性評価、パッチ管理、リスク評価など、脆弱性ライフサイクル全体の管理に使用します。
  キーワード - 脆弱性、CVE、NVD、OWASP、スキャナー、パッチ、リスク評価、脆弱性診断。
version: 1.0.0
---

# 脆弱性管理スキル

## 目的

このスキルは、組織の脆弱性管理プログラムを確立、実装、維持するための包括的なガイダンスを提供します。
脆弱性の発見、評価、優先順位付け、修復、検証のサイクル全体をカバーし、
効果的な脆弱性管理プロセスを実現するための実践的な知識を含みます。

## このスキルを使用する場合

以下の場合にこのスキルを使用します:

- ユーザーが脆弱性管理プロセスの構築や改善を求めた場合
- ユーザーが脆弱性スキャンの実施や結果分析を必要とする場合
- ユーザーがCVE、NVD、OWASP Top 10 の理解を求めた場合
- ユーザーがリスク評価や優先順位付けの方法を知りたい場合
- ユーザーがパッチ管理プロセスを構築したい場合
- ユーザーが「脆弱性」、「CVE」、「スキャン」と言及した場合

## 脆弱性管理の基礎

### 脆弱性管理ライフサイクル

1. **発見（Discovery）**
   - 自動スキャン
   - ペネトレーションテスト
   - バグバウンティ
   - 脅威インテリジェンス

2. **評価（Assessment）**
   - CVSSスコア算出
   - 影響範囲の特定
   - 悪用可能性の判断

3. **優先順位付け（Prioritization）**
   - ビジネスインパクト
   - 悪用の容易さ
   - 資産の重要度

4. **修復（Remediation）**
   - パッチ適用
   - 設定変更
   - 代替制御

5. **検証（Verification）**
   - 再スキャン
   - 修復確認
   - 文書化

6. **報告（Reporting）**
   - ダッシュボード
   - メトリクス
   - トレンド分析

## CVEとNVD

### CVE (Common Vulnerabilities and Exposures)

**CVE ID形式**: CVE-YYYY-NNNNN
- 例: CVE-2021-44228 (Log4Shell)

**CVE情報取得:**

```bash
# CVE検索
curl -s "https://cve.circl.lu/api/cve/CVE-2021-44228" | jq

# CVE詳細
curl -s "https://services.nvd.nist.gov/rest/json/cve/1.0/CVE-2021-44228" | jq
```

**Python CVE検索:**

```python
import requests

def get_cve_info(cve_id):
    url = f"https://services.nvd.nist.gov/rest/json/cve/1.0/{cve_id}"
    response = requests.get(url)
    if response.status_code == 200:
        data = response.json()
        cve = data['result']['CVE_Items'][0]
        return {
            'id': cve_id,
            'description': cve['cve']['description']['description_data'][0]['value'],
            'cvss_v3': cve['impact']['baseMetricV3']['cvssV3']['baseScore'],
            'published': cve['publishedDate']
        }
    return None

cve_info = get_cve_info('CVE-2021-44228')
print(f"CVSS Score: {cve_info['cvss_v3']}")
```

### CVSS (Common Vulnerability Scoring System)

**CVSS v3.1スコアリング:**

**Base Metrics:**
- Attack Vector (AV): Network/Adjacent/Local/Physical
- Attack Complexity (AC): Low/High
- Privileges Required (PR): None/Low/High
- User Interaction (UI): None/Required
- Scope (S): Unchanged/Changed
- Confidentiality Impact (C): None/Low/High
- Integrity Impact (I): None/Low/High
- Availability Impact (A): None/Low/High

**スコア範囲:**
- 0.0: なし
- 0.1-3.9: 低
- 4.0-6.9: 中
- 7.0-8.9: 高
- 9.0-10.0: 致命的

**CVSSスコア計算:**

```python
def calculate_cvss_base_score(av, ac, pr, ui, s, c, i, a):
    # Attack Vector
    av_values = {'N': 0.85, 'A': 0.62, 'L': 0.55, 'P': 0.2}
    # Attack Complexity
    ac_values = {'L': 0.77, 'H': 0.44}
    # Privileges Required
    pr_values = {
        'N': {'U': 0.85, 'C': 0.85},
        'L': {'U': 0.62, 'C': 0.68},
        'H': {'U': 0.27, 'C': 0.50}
    }
    # User Interaction
    ui_values = {'N': 0.85, 'R': 0.62}
    # Impacts
    impact_values = {'N': 0.0, 'L': 0.22, 'H': 0.56}

    # Exploitability
    exploitability = 8.22 * av_values[av] * ac_values[ac] * pr_values[pr][s] * ui_values[ui]

    # Impact
    isc_base = 1 - ((1 - impact_values[c]) * (1 - impact_values[i]) * (1 - impact_values[a]))

    if s == 'U':
        impact = 6.42 * isc_base
    else:
        impact = 7.52 * (isc_base - 0.029) - 3.25 * ((isc_base - 0.02) ** 15)

    # Base Score
    if impact <= 0:
        return 0.0
    elif s == 'U':
        return min(10, (impact + exploitability))
    else:
        return min(10, 1.08 * (impact + exploitability))

# 使用例
score = calculate_cvss_base_score(
    av='N', ac='L', pr='N', ui='N', s='U',
    c='H', i='H', a='H'
)
print(f"CVSS Base Score: {score:.1f}")  # 9.8 (Critical)
```

## OWASP Top 10

### OWASP Top 10 (2021)

1. **A01:2021-Broken Access Control**
   - 不適切な認可チェック
   - IDOR（Insecure Direct Object References）
   - パストラバーサル

2. **A02:2021-Cryptographic Failures**
   - 弱い暗号化
   - 平文での機密データ保存
   - 不適切な証明書検証

3. **A03:2021-Injection**
   - SQLインジェクション
   - コマンドインジェクション
   - LDAPインジェクション

4. **A04:2021-Insecure Design**
   - 脅威モデリングの欠如
   - セキュアな設計原則の未適用
   - ビジネスロジックの脆弱性

5. **A05:2021-Security Misconfiguration**
   - デフォルト設定
   - 不要な機能の有効化
   - エラーメッセージでの情報漏洩

6. **A06:2021-Vulnerable and Outdated Components**
   - 古いライブラリ
   - 未パッチのソフトウェア
   - サポート終了製品

7. **A07:2021-Identification and Authentication Failures**
   - 弱いパスワードポリシー
   - セッション管理の不備
   - 総当たり攻撃対策の欠如

8. **A08:2021-Software and Data Integrity Failures**
   - 署名されていない更新
   - CI/CDパイプラインの脆弱性
   - 依存関係の改ざん

9. **A09:2021-Security Logging and Monitoring Failures**
   - 不十分なログ記録
   - アラートの欠如
   - インシデント対応の遅延

10. **A10:2021-Server-Side Request Forgery (SSRF)**
    - 内部リソースへの不正アクセス
    - クラウドメタデータの取得
    - ポートスキャン

## 脆弱性スキャンツール

### Nessus

**Nessusスキャン（CLI）:**

```bash
# ログイン
curl -k -X POST -H 'Content-Type: application/json' \
  -d '{"username":"admin","password":"password"}' \
  https://localhost:8834/session

# スキャン作成
curl -k -X POST -H "X-Cookie: token=YOUR_TOKEN" \
  -H 'Content-Type: application/json' \
  -d '{"uuid":"template_uuid","settings":{"name":"My Scan","text_targets":"192.168.1.0/24"}}' \
  https://localhost:8834/scans

# スキャン開始
curl -k -X POST -H "X-Cookie: token=YOUR_TOKEN" \
  https://localhost:8834/scans/SCAN_ID/launch

# 結果取得
curl -k -H "X-Cookie: token=YOUR_TOKEN" \
  https://localhost:8834/scans/SCAN_ID/export?format=nessus
```

### OpenVAS

**OpenVAS/GVMスキャン:**

```bash
# スキャン設定作成
gvm-cli socket --xml "<create_target><name>Target 1</name><hosts>192.168.1.0/24</hosts></create_target>"

# タスク作成
gvm-cli socket --xml "<create_task><name>Scan Task</name><config id='daba56c8-73ec-11df-a475-002264764cea'/><target id='TARGET_ID'/><scanner id='08b69003-5fc2-4037-a479-93b440211c73'/></create_task>"

# スキャン実行
gvm-cli socket --xml "<start_task task_id='TASK_ID'/>"

# 結果取得
gvm-cli socket --xml "<get_results task_id='TASK_ID'/>"
```

**Python-GVMでの自動化:**

```python
from gvm.connections import UnixSocketConnection
from gvm.protocols.gmp import Gmp
from gvm.transforms import EtreeTransform

connection = UnixSocketConnection()
transform = EtreeTransform()

with Gmp(connection, transform=transform) as gmp:
    # 認証
    gmp.authenticate('admin', 'password')

    # ターゲット作成
    target = gmp.create_target(
        name='Scan Target',
        hosts=['192.168.1.0/24']
    )
    target_id = target.get('id')

    # タスク作成
    task = gmp.create_task(
        name='Vulnerability Scan',
        config_id='daba56c8-73ec-11df-a475-002264764cea',
        target_id=target_id,
        scanner_id='08b69003-5fc2-4037-a479-93b440211c73'
    )
    task_id = task.get('id')

    # スキャン開始
    gmp.start_task(task_id)

    # 結果取得（完了後）
    results = gmp.get_results(task_id=task_id)
```

### Qualys

**Qualys API:**

```python
import requests
from requests.auth import HTTPBasicAuth

class QualysAPI:
    def __init__(self, username, password, api_url):
        self.username = username
        self.password = password
        self.api_url = api_url

    def launch_scan(self, scan_title, target_ips):
        url = f"{self.api_url}/api/2.0/fo/scan/"
        data = {
            'action': 'launch',
            'scan_title': scan_title,
            'ip': target_ips,
            'option_title': 'Initial Options'
        }
        response = requests.post(
            url,
            auth=HTTPBasicAuth(self.username, self.password),
            data=data
        )
        return response.text

    def get_scan_results(self, scan_ref):
        url = f"{self.api_url}/api/2.0/fo/scan/"
        params = {
            'action': 'fetch',
            'scan_ref': scan_ref,
            'mode': 'extended',
            'output_format': 'xml'
        }
        response = requests.get(
            url,
            auth=HTTPBasicAuth(self.username, self.password),
            params=params
        )
        return response.text

# 使用例
qualys = QualysAPI('username', 'password', 'https://qualysapi.qualys.com')
scan_ref = qualys.launch_scan('Monthly Scan', '192.168.1.0-192.168.1.255')
```

### Nikto (Webサーバースキャナー)

```bash
# 基本スキャン
nikto -h http://example.com

# SSL/TLS有効
nikto -h https://example.com -ssl

# 特定ポート
nikto -h example.com -port 8080

# 結果をHTMLで保存
nikto -h example.com -o report.html -Format html

# Tuningオプション（特定のテストのみ）
nikto -h example.com -Tuning 1,2,3
```

## 脆弱性評価とリスク分析

### リスク評価マトリックス

```python
class VulnerabilityRiskAssessment:
    def __init__(self):
        # 資産価値
        self.asset_value = {
            'critical': 5,
            'high': 4,
            'medium': 3,
            'low': 2,
            'minimal': 1
        }

        # 脅威レベル
        self.threat_level = {
            'critical': 5,
            'high': 4,
            'medium': 3,
            'low': 2,
            'minimal': 1
        }

    def calculate_risk(self, cvss_score, asset_value, exploitability, exposure):
        """
        リスクスコア = (CVSS * 0.3) + (資産価値 * 0.3) + (悪用可能性 * 0.2) + (露出度 * 0.2)
        """
        risk_score = (
            (cvss_score * 0.3) +
            (self.asset_value.get(asset_value, 0) * 2 * 0.3) +
            (exploitability * 0.2) +
            (exposure * 0.2)
        )
        return risk_score

    def prioritize(self, risk_score):
        if risk_score >= 8:
            return 'P1 - 即時対応（24時間以内）'
        elif risk_score >= 6:
            return 'P2 - 緊急対応（1週間以内）'
        elif risk_score >= 4:
            return 'P3 - 通常対応（1ヶ月以内）'
        else:
            return 'P4 - 計画的対応（次回メンテナンス）'

# 使用例
risk_assessment = VulnerabilityRiskAssessment()

vulnerability = {
    'cvss_score': 9.8,
    'asset_value': 'critical',
    'exploitability': 9,  # 0-10
    'exposure': 10  # 0-10（インターネット公開）
}

risk_score = risk_assessment.calculate_risk(
    vulnerability['cvss_score'],
    vulnerability['asset_value'],
    vulnerability['exploitability'],
    vulnerability['exposure']
)

priority = risk_assessment.prioritize(risk_score)
print(f"リスクスコア: {risk_score:.1f}, 優先度: {priority}")
```

### EPSS (Exploit Prediction Scoring System)

実際の悪用確率を予測

```python
import requests

def get_epss_score(cve_id):
    url = f"https://api.first.org/data/v1/epss?cve={cve_id}"
    response = requests.get(url)
    if response.status_code == 200:
        data = response.json()
        if data['data']:
            epss = data['data'][0]['epss']
            percentile = data['data'][0]['percentile']
            return {
                'epss': float(epss),
                'percentile': float(percentile)
            }
    return None

# 使用例
epss = get_epss_score('CVE-2021-44228')
print(f"Exploit Probability: {epss['epss']*100:.2f}%")
print(f"Percentile: {epss['percentile']*100:.2f}%")
```

## パッチ管理

### パッチ管理プロセス

1. **パッチの特定**
   - ベンダー通知の監視
   - セキュリティアドバイザリ
   - 脆弱性スキャン結果

2. **評価**
   - パッチの重要度
   - ビジネスへの影響
   - 互換性テスト

3. **テスト**
   - テスト環境での検証
   - アプリケーション互換性
   - ロールバック計画

4. **展開**
   - 段階的展開
   - メンテナンス窓
   - モニタリング

5. **検証**
   - パッチ適用確認
   - 機能テスト
   - 脆弱性再スキャン

### 自動パッチ管理

**Linux (Debian/Ubuntu):**

```bash
# 自動セキュリティアップデート
apt install unattended-upgrades
dpkg-reconfigure -plow unattended-upgrades

# 設定（/etc/apt/apt.conf.d/50unattended-upgrades）
Unattended-Upgrade::Allowed-Origins {
    "${distro_id}:${distro_codename}-security";
};
Unattended-Upgrade::Automatic-Reboot "true";
Unattended-Upgrade::Automatic-Reboot-Time "02:00";
```

**Windows (PowerShell):**

```powershell
# Windows Update自動化
Install-Module PSWindowsUpdate -Force
Import-Module PSWindowsUpdate

# すべての更新プログラムのインストール
Get-WindowsUpdate -Install -AcceptAll -AutoReboot

# セキュリティ更新のみ
Get-WindowsUpdate -Category "Security Updates" -Install -AcceptAll

# WSUS設定
Set-ItemProperty -Path "HKLM:\SOFTWARE\Policies\Microsoft\Windows\WindowsUpdate\AU" -Name AUOptions -Value 4
```

## 脆弱性データベースとフィード

### 主要な脆弱性データベース

1. **NVD (National Vulnerability Database)**
   - https://nvd.nist.gov/

2. **CVE (MITRE)**
   - https://cve.mitre.org/

3. **VulnDB**
   - Commercial database

4. **Exploit-DB**
   - https://www.exploit-db.com/

5. **GitHub Advisory Database**
   - https://github.com/advisories

### 脆弱性フィードの自動化

```python
import feedparser
import requests

def fetch_nvd_feed():
    """NVDの脆弱性フィードを取得"""
    url = "https://nvd.nist.gov/feeds/json/cve/1.1/nvdcve-1.1-recent.json.gz"
    response = requests.get(url)

    if response.status_code == 200:
        import gzip
        import json
        data = json.loads(gzip.decompress(response.content))
        return data['CVE_Items']
    return []

def parse_cve_items(items):
    """CVE項目を解析"""
    vulnerabilities = []
    for item in items:
        cve = item['cve']
        cve_id = cve['CVE_data_meta']['ID']

        # CVSS スコア
        if 'baseMetricV3' in item.get('impact', {}):
            cvss = item['impact']['baseMetricV3']['cvssV3']['baseScore']
        else:
            cvss = 0.0

        vulnerabilities.append({
            'id': cve_id,
            'description': cve['description']['description_data'][0]['value'],
            'cvss': cvss,
            'published': item['publishedDate']
        })

    return vulnerabilities

# 使用例
cve_items = fetch_nvd_feed()
vulnerabilities = parse_cve_items(cve_items[:10])

for vuln in vulnerabilities:
    print(f"{vuln['id']}: CVSS {vuln['cvss']}")
```

## 継続的な脆弱性管理

### 自動スキャンスケジュール

```python
from apscheduler.schedulers.blocking import BlockingScheduler

def weekly_vulnerability_scan():
    """週次脆弱性スキャン"""
    print("Starting weekly vulnerability scan...")
    # スキャンロジック
    run_openvas_scan(targets=['production_servers'])
    analyze_results()
    send_report()

def daily_web_app_scan():
    """日次Webアプリケーションスキャン"""
    print("Starting daily web application scan...")
    run_nikto_scan(url='https://webapp.example.com')

def monthly_full_scan():
    """月次フルスキャン"""
    print("Starting monthly comprehensive scan...")
    run_nessus_scan(targets=['all_assets'])

scheduler = BlockingScheduler()
scheduler.add_job(daily_web_app_scan, 'cron', hour=2)
scheduler.add_job(weekly_vulnerability_scan, 'cron', day_of_week='sun', hour=1)
scheduler.add_job(monthly_full_scan, 'cron', day=1, hour=0)

scheduler.start()
```

### メトリクスとKPI

```python
class VulnerabilityMetrics:
    def __init__(self, db_connection):
        self.db = db_connection

    def mean_time_to_detect(self):
        """MTTD - 平均検出時間"""
        query = "SELECT AVG(detected_date - published_date) FROM vulnerabilities"
        return self.db.execute(query).fetchone()[0]

    def mean_time_to_remediate(self):
        """MTTR - 平均修復時間"""
        query = "SELECT AVG(remediated_date - detected_date) FROM vulnerabilities WHERE status='remediated'"
        return self.db.execute(query).fetchone()[0]

    def vulnerability_density(self):
        """脆弱性密度（資産あたりの脆弱性数）"""
        query = """
            SELECT
                COUNT(v.id) * 1.0 / COUNT(DISTINCT a.id)
            FROM vulnerabilities v
            JOIN assets a ON v.asset_id = a.id
        """
        return self.db.execute(query).fetchone()[0]

    def remediation_rate(self):
        """修復率"""
        query = """
            SELECT
                COUNT(CASE WHEN status='remediated' THEN 1 END) * 100.0 / COUNT(*)
            FROM vulnerabilities
            WHERE detected_date >= DATE('now', '-30 days')
        """
        return self.db.execute(query).fetchone()[0]

    def generate_dashboard(self):
        return {
            'mttd_days': self.mean_time_to_detect(),
            'mttr_days': self.mean_time_to_remediate(),
            'vulnerability_density': self.vulnerability_density(),
            'remediation_rate_%': self.remediation_rate()
        }
```

## ベストプラクティス

1. **定期的なスキャン**
   - 週次または月次の自動スキャン
   - 変更後のオンデマンドスキャン
   - 継続的なモニタリング

2. **リスクベースのアプローチ**
   - CVSSだけでなく、ビジネスインパクトを考慮
   - 資産の重要度による優先順位付け
   - 悪用の現実性（EPSS）の考慮

3. **統合と自動化**
   - CI/CDパイプラインへの統合
   - チケットシステムとの連携
   - 自動化されたパッチ展開

4. **ドキュメントと報告**
   - すべての脆弱性を追跡
   - 修復進捗のレポート
   - 経営層向けダッシュボード

5. **継続的改善**
   - メトリクスのレビュー
   - プロセスの最適化
   - ツールとスキルの更新

## 参考リソース

- NIST SP 800-40: Guide to Enterprise Patch Management
- CIS Controls v8: Asset Management and Vulnerability Management
- OWASP Testing Guide
- SANS Top 20 Critical Security Controls
- ISO/IEC 27002

## 注意事項

- **許可**: スキャンは必ず許可を得てから実施すること
- **影響**: 本番環境へのスキャン影響を考慮すること
- **誤検知**: 自動スキャン結果は必ず手動で検証すること
- **プライバシー**: 個人情報の取り扱いに注意すること
- **コンプライアンス**: 関連する法規制を遵守すること
