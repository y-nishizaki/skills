---
name: "コード作成"
description: "新規コード作成時の思考プロセス。新規、作成、実装、機能追加、開発に関する依頼に対応"
---

# コード作成: 新規コード作成時の思考プロセス

## このスキルを使う場面

- 新しい機能・コンポーネント・モジュールを作成する
- 既存のコードベースに新機能を追加する
- ゼロから実装が必要な場合
- プロトタイプを作成する
- API・インターフェースを実装する

## 思考プロセス

### フェーズ1: 要件の明確化

**ステップ1: 要件の理解と確認**

以下のチェックリストで要件を明確にする：

**機能要件:**

- [ ] 何を実現する必要があるか明確か
- [ ] 入力は何か（型・形式・範囲）
- [ ] 出力は何か（型・形式・範囲）
- [ ] エッジケースを特定したか
- [ ] 異常系の処理を定義したか

**非機能要件:**

- [ ] パフォーマンス要件（速度・メモリ）
- [ ] セキュリティ要件
- [ ] 可用性・信頼性の要件
- [ ] 保守性・拡張性の要件

**制約条件:**

- [ ] 使用する言語・フレームワーク
- [ ] 既存コードとの互換性
- [ ] 依存ライブラリの制限
- [ ] コーディング規約・スタイル

**ステップ2: 不明点の明確化**

以下が不明確な場合はユーザーに確認：

1. **機能の境界**: どこまでがスコープか
2. **優先順位**: 複数の要件がある場合の優先度
3. **例**: 具体的な使用例・ユースケース
4. **期待動作**: 曖昧なケースでの振る舞い

**ステップ3: 成功の定義**

完了の基準を明確にする：

- [ ] どうなれば「完成」か
- [ ] どうやって検証するか
- [ ] 何をテストすべきか

**移行条件:**

- [ ] 要件を完全に理解した
- [ ] 不明点をすべて解消した
- [ ] 成功の基準を定義した

### フェーズ2: 設計と計画

**ステップ1: 設計の思考順序**

以下の順序で設計を考える：

**1. シンプルさ優先**

- 最もシンプルな実装から考える
- YAGNI 原則（You Aren't Gonna Need It）を適用
- 必要になってから複雑化する

**2. インターフェース設計**

- 外部から見たインターフェースを先に決める
- 関数名・引数・戻り値
- クラスの public メソッド
- API のエンドポイント

**3. データ構造の決定**

- どんなデータを扱うか
- データの流れ（入力 → 処理 → 出力）
- 状態管理の必要性

**4. 処理の分解**

- 大きな処理を小さな単位に分解
- 単一責任の原則を適用
- 各部分が独立してテスト可能か

**ステップ2: アプローチの選択**

複数のアプローチがある場合の判断基準：

1. **シンプルさ**: より単純な方を選ぶ
2. **既存パターン**: コードベースの既存パターンに従う
3. **保守性**: 将来変更しやすい方
4. **パフォーマンス**: 要件を満たす範囲で
5. **テスタビリティ**: テストしやすい方

**ステップ3: 実装の段階分け**

実装を段階的に進めるための計画：

1. **最小動作版（MVP）**
   - 最も基本的な機能だけ実装
   - 早期に動作確認
   - フィードバックを得る

2. **機能の追加**
   - 一つずつ機能を追加
   - 各段階で動作確認
   - 段階的に完成度を上げる

3. **エラー処理・エッジケース**
   - 基本機能が動いてから
   - 異常系を順次対応

4. **最適化・リファクタリング**
   - 動作確認後に改善
   - 必要に応じて最適化

**移行条件:**

- [ ] インターフェースを設計した
- [ ] データ構造を決定した
- [ ] 処理を分解した
- [ ] 実装の段階を計画した

### フェーズ3: 実装

**ステップ1: インターフェースの実装**

まずインターフェース・型定義から始める：

1. **型定義・インターフェース**
   - 関数のシグネチャ
   - クラス・インターフェースの定義
   - データ型の定義

2. **仮実装（スタブ）**
   - 最小限の実装でコンパイル/実行可能に
   - TODO コメントで未実装箇所をマーク
   - テストの枠組みを作成

3. **検証**
   - インターフェースが適切か確認
   - 型が正しいか確認
   - 呼び出し側のコードを書いてみる

**ステップ2: 本体の実装**

段階的に本体を実装：

1. **ハッピーパスの実装**
   - 正常系の基本的な流れ
   - 最も一般的なケース
   - エラー処理は後回し

2. **動作確認**
   - 簡単なテストケースで検証
   - ログ・デバッグ出力で確認
   - 期待通りの動作か確認

3. **エッジケースの実装**
   - 境界値の処理
   - 空データ・Null の処理
   - 特殊なケースへの対応

4. **エラー処理の実装**
   - 入力検証
   - 例外処理
   - エラーメッセージ

**ステップ3: コードの品質確保**

実装しながら品質を保つ：

1. **命名**
   - 分かりやすい変数名・関数名
   - 規約に従った命名
   - 一貫性のある命名

2. **コメント**
   - なぜ（Why）を説明
   - 何（What）はコードで表現
   - 複雑な箇所に補足説明

3. **コードの整理**
   - 適切なインデント
   - 論理的な順序
   - 関数・クラスの適切な分割

**移行条件:**

- [ ] インターフェースを実装した
- [ ] ハッピーパスが動作する
- [ ] エッジケースを処理した
- [ ] エラー処理を実装した

### フェーズ4: テストと検証

**ステップ1: 各段階での検証ポイント**

実装の各段階で以下を検証：

**正常系のテスト:**

- [ ] 基本的な入力で正しく動作するか
- [ ] 期待した出力が得られるか
- [ ] 複数のケースで試したか

**異常系のテスト:**

- [ ] 無効な入力で適切にエラーになるか
- [ ] エラーメッセージが分かりやすいか
- [ ] 例外が適切に処理されるか

**エッジケースのテスト:**

- [ ] 境界値（0, 最大値等）で動作するか
- [ ] 空データ（空配列、空文字列等）で動作するか
- [ ] Null/undefined で問題ないか

**ステップ2: テストの作成**

実装に応じたテストを作成：

1. **ユニットテスト**
   - 個々の関数・メソッドのテスト
   - 独立してテスト可能に
   - モック・スタブの活用

2. **統合テスト**
   - コンポーネント間の連携
   - 実際の使用シナリオ
   - データの流れの確認

3. **手動テスト**
   - UI がある場合
   - 実際の使用感の確認
   - 見落としがないか最終確認

**ステップ3: 品質の最終確認**

- [ ] すべてのテストがパスする
- [ ] コーディング規約に従っている
- [ ] 不要なコード（デバッグ用等）を削除した
- [ ] コメント・ドキュメントが適切
- [ ] パフォーマンスが許容範囲内

**移行条件:**

- [ ] すべてのテストがパスした
- [ ] エッジケースを確認した
- [ ] 品質基準を満たした

### フェーズ5: レビューとドキュメント

**ステップ1: 自己レビュー**

コミット前に自分でレビュー：

1. **コードレビュー**
   - 実装が要件を満たしているか
   - 無駄なコードがないか
   - 改善できる箇所はないか

2. **テストの確認**
   - テストカバレッジは十分か
   - 重要なケースを網羅しているか
   - テストが適切に失敗するか確認

3. **影響範囲の確認**
   - 既存機能に影響しないか
   - 依存関係は適切か
   - 後方互換性は保たれているか

**ステップ2: ドキュメントの作成・更新**

必要に応じてドキュメントを更新：

1. **コード内ドキュメント**
   - 関数・クラスのドキュメントコメント
   - 複雑な処理の説明
   - 使用例

2. **外部ドキュメント**
   - API ドキュメント
   - README の更新
   - 変更履歴

3. **使用例**
   - 典型的な使用例
   - エッジケースの扱い方
   - 注意点

**移行条件:**

- [ ] 自己レビュー完了
- [ ] ドキュメント作成・更新完了
- [ ] コミット準備完了

## 判断のポイント

### どれくらい設計すべきか

**簡単なタスク（数十行）:**

- 詳細な設計不要
- 頭の中で整理してすぐ実装
- ただし、インターフェースは考える

**中規模のタスク（数百行）:**

- インターフェースと主要な処理の流れを設計
- データ構造を決める
- 実装の段階を計画

**大規模なタスク（数千行以上）:**

- system-design スキルを先に適用
- アーキテクチャから考える
- コンポーネント分割を明確に

### いつテストを書くべきか

**TDD（テスト駆動開発）が適している場合:**

- 要件が明確
- インターフェースが固まっている
- バグを許容できない（金融、医療等）

**実装後にテストが適している場合:**

- プロトタイプ・探索的実装
- インターフェースが未確定
- 仕様が流動的

**推奨アプローチ:**

- インターフェースを先に決める
- 基本的なテストケースを書く
- 実装する
- テストを追加・拡充

### いつリファクタリングすべきか

**すぐにリファクタリング:**

- コードの重複を見つけた
- 明らかに分かりにくい
- 将来の変更が困難

**後でリファクタリング:**

- まだ動作確認できていない
- スコープを広げすぎる
- 動作するコードがまだない

**原則:**

- まず動かす
- 次にキレイにする
- 最後に最適化する

## よくある落とし穴

1. **要件理解の不足**
   - ❌ 曖昧なまま実装開始
   - ✅ 不明点を明確にしてから開始

2. **過剰な設計**
   - ❌ 将来を見越して複雑な実装
   - ✅ シンプルに始めて必要に応じて拡張

3. **インターフェース後回し**
   - ❌ 実装から始める
   - ✅ インターフェースを先に決める

4. **一度に全部実装**
   - ❌ すべてを実装してからテスト
   - ✅ 段階的に実装・検証

5. **エラー処理の軽視**
   - ❌ ハッピーパスだけ実装
   - ✅ エラー処理も適切に実装

6. **テストの省略**
   - ❌ 「簡単だから」テスト不要
   - ✅ 必ず検証する

7. **命名の軽視**
   - ❌ とりあえず動けばいい命名
   - ✅ 分かりやすい名前をつける

## 検証ポイント

### 要件の検証

- [ ] すべての機能要件を満たしているか
- [ ] 非機能要件を満たしているか
- [ ] エッジケースを考慮したか
- [ ] 異常系を処理したか

### 設計の検証

- [ ] インターフェースが適切か
- [ ] データ構造が適切か
- [ ] 処理が適切に分解されているか
- [ ] テスト可能な設計か

### 実装の検証

- [ ] コードが動作するか
- [ ] すべてのテストがパスするか
- [ ] コーディング規約に従っているか
- [ ] 無駄なコードがないか

### 品質の検証

- [ ] 可読性が高いか
- [ ] 保守性が高いか
- [ ] パフォーマンスが適切か
- [ ] セキュリティ上の問題がないか

## 他スキルとの連携

### code-creation → system-design

大規模な新機能の場合：

1. まず system-design スキルでアーキテクチャを設計
2. その後、このスキルで個々のコンポーネントを実装

### code-creation → code-review

実装完了後：

1. 自己レビュー（このスキルの一部）
2. code-review スキルでより詳細なレビュー
3. 必要に応じて修正

### code-creation → refactoring

実装完了後、品質に改善の余地がある場合：

1. まず動作するコードを完成させる（このスキル）
2. refactoring スキルで改善
3. ただし、明らかな問題は実装中に修正

### code-creation → documentation

実装完了後：

1. コード内ドキュメント（このスキルの一部）
2. documentation スキルで外部ドキュメント作成
3. 使用例・チュートリアルの作成

### code-creation + debugging

実装中にバグに遭遇：

1. debugging スキルで問題を特定・修正
2. このスキルに戻って実装継続
3. バグを防ぐテストを追加

## 実装のベストプラクティス

### DRY（Don't Repeat Yourself）

- コードの重複を避ける
- 共通処理は関数・クラスに抽出
- ただし、過度な抽象化は避ける

### KISS（Keep It Simple, Stupid）

- シンプルな実装を優先
- 複雑さは必要になってから追加
- 読みやすさを重視

### YAGNI（You Aren't Gonna Need It）

- 今必要ない機能は実装しない
- 将来の拡張を見越しすぎない
- シンプルに始めて徐々に拡張

### 単一責任の原則

- 関数・クラスは一つの責任だけ
- 責任が複数ある場合は分割
- テストしやすく、変更しやすく

### 早期リターン

- ガード節で早期リターン
- ネストを浅く保つ
- 可読性の向上
