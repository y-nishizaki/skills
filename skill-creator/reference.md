# スキル作成リファレンスドキュメント

## 目次

1. [YAMLフロントマター仕様](#yamlフロントマター仕様)
2. [ファイル構造パターン](#ファイル構造パターン)
3. [説明の書き方ガイド](#説明の書き方ガイド)
4. [指示の書き方ベストプラクティス](#指示の書き方ベストプラクティス)
5. [ツール使用ガイドライン](#ツール使用ガイドライン)
6. [テストと検証](#テストと検証)
7. [よくある落とし穴](#よくある落とし穴)
8. [高度なパターン](#高度なパターン)

---

## YAMLフロントマター仕様

### 必須フィールド

#### name

- **型**: 文字列
- **最大長**: 64文字
- **形式**: ハイフン区切りの小文字（ケバブケース）
- **例**: `skill-creator`、`code-reviewer`、`api-tester`
- **検証**: ユニークで、英数字とハイフンのみ

#### description

- **型**: 文字列
- **最大長**: 200文字
- **目的**: Claudeがスキルを起動するタイミングを決定するのを支援
- **必須内容**:
  - スキルが何をするか
  - いつ使用するか
  - トリガーキーワード
- **例**: "適切な構造とベストプラクティスで新しいClaude Codeスキルを作成します。スキル構築、機能生成、カスタムツール作成時に使用します。"

### 任意フィールド

#### version

- **型**: 文字列（セマンティックバージョニング）
- **形式**: `MAJOR.MINOR.PATCH`
- **例**: `1.0.0`、`2.1.3`
- **目的**: スキルの反復と変更を追跡

#### dependencies

- **型**: 文字列または配列
- **形式**: パッケージ仕様
- **例**:
  - 単一: `python>=3.8`
  - 複数: `python>=3.8, node>=18, docker`
- **目的**: 必要なソフトウェア/ツールを文書化

### YAML構文ルール

1. **区切り文字**: 別の行に`---`で開始と終了が必要
2. **スペーシング**: スペースのみ使用、タブは不可
3. **インデント**: レベルごとに2スペース
4. **引用符**: 特殊文字を含む値には引用符を使用
5. **リスト**: 配列項目にはスペース付き`-`プレフィックスを使用

### 有効なYAML例

```yaml
---
name: example-skill
description: これは適切なYAMLフォーマットと必須フィールドを示すサンプルスキルです。
version: 1.0.0
dependencies: python>=3.8
---
```

### 無効なYAML例

```yaml
# 終了区切り文字がない
---
name: example-skill
description: 終了区切り文字がありません

# タブの使用（ここでは見えませんがエラーの原因になります）
---
name:→example-skill
description:→不適切なフォーマット

# 名前が長すぎる
---
name: this-is-an-extremely-long-skill-name-that-exceeds-sixty-four-characters-limit
description: これは検証に失敗します
```

---

## ファイル構造パターン

### 最小スキル（シンプルなタスク）

```
skill-name/
└── SKILL.md
```

**使用タイミング**:

- シンプルで直接的な機能
- 外部依存関係なし
- 最小限のドキュメントが必要
- 例がメインファイルに収まる

### 標準スキル（最も一般的）

```
skill-name/
├── SKILL.md
├── reference.md
└── examples.md
```

**使用タイミング**:

- 中程度の複雑さ
- 拡張例が必要
- 技術仕様が有益
- APIまたはフォーマットリファレンスが必要

### 複雑なスキル（高度なワークフロー）

```
skill-name/
├── SKILL.md
├── reference.md
├── examples.md
├── templates/
│   ├── template1.md
│   └── template2.json
└── scripts/
    ├── helper.py
    └── validator.sh
```

**使用タイミング**:

- 複雑な複数ステップのプロセス
- テンプレートからファイルを生成
- ヘルパースクリプトが必要
- 複数の設定オプション
- ドメイン固有の知識

### テンプレート重視のスキル

```
skill-name/
├── SKILL.md
└── templates/
    ├── basic.md
    ├── advanced.md
    └── config.yaml
```

**使用タイミング**:

- 主な機能がファイル生成
- 複数のテンプレートバリエーション
- スキャフォールディングまたはボイラープレート生成
- プロジェクト初期化

---

## 説明の書き方ガイド

### 説明の目的

説明フィールドは2つの重要な機能を果たします：

1. Claudeがスキルを起動するタイミングを決定するのを支援
2. スキルの機能に関するコンテキストを提供

### 説明の公式

```
[何をするか] + [いつ使用するか] + [トリガーキーワード]
```

### 良い説明の例

```yaml
description: "バグ、パフォーマンス問題、ベストプラクティスについてコードをレビューします。コードレビュー、品質チェック、パターン分析時に使用します。キーワード: コードレビュー、コード確認、PRレビュー。"
```

**良い理由**:

- 明確な機能
- 具体的なユースケース
- 明示的なトリガーキーワード
- 200文字以下

```yaml
description: "コードコメントと型定義からAPIドキュメントを生成します。API文書化、リファレンス作成、ドキュメント更新時に使用します。キーワード: APIドキュメント、ドキュメント化、ドキュメント生成。"
```

**良い理由**:

- 正確なアクション
- アクティベーションのコンテキスト
- ユーザー言語のキーワード

### 悪い説明の例

```yaml
description: "コード用の便利なスキル"
```

**問題点**:

- 曖昧すぎる
- トリガーキーワードなし
- 使用タイミングが不明確
- 最小限のコンテキスト

```yaml
description: "この非常に包括的なスキルは、構文チェック、セマンティック分析、パフォーマンス最適化提案、セキュリティ脆弱性検出、ベストプラクティス適用を含むコードレビューのすべての側面を処理します。"
```

**問題点**:

- 長すぎる
- 過度に複雑
- 多くのことをやろうとしすぎ
- 複数のスキルに分割すべき

### トリガーキーワード戦略

**以下のタイプを含める**:

1. **動作動詞**: 作成、構築、生成、レビュー、分析、テスト
2. **ドメイン用語**: API、データベース、フロントエンド、バックエンド、DevOps
3. **ユーザーフレーズ**: "〜を手伝って"、"〜を作成"、"〜をレビュー"
4. **略語**: PR、CI/CD、API、DB

**キーワードリストの例**:

```yaml
# コードレビュースキル
キーワード: レビュー、チェック、分析、PR、プルリクエスト、コード品質

# データベースマイグレーションスキル
キーワード: マイグレート、マイグレーション、データベース、スキーマ、DB

# コンポーネント生成スキル
キーワード: コンポーネント、生成、作成、スキャフォールド、ボイラープレート
```

---

## 指示の書き方ベストプラクティス

### 指示を構造化する

階層構造を使用します：

```markdown
## 指示

### フェーズ1: 準備
#### ステップ1.1: リクエストを分析
- サブステップの詳細
- 確認すべきこと
- 検証方法

#### ステップ1.2: リソースを収集
- どのようなリソース
- どこで見つけるか
- 検証方法

### フェーズ2: 実行
[パターンを続ける...]
```

### 具体的で実行可能にする

**悪い**:

```markdown
## 指示
コードをレビューしてフィードバックを提供します。
```

**良い**:

```markdown
## 指示

### ステップ1: コード分析
1. Readツールを使用してファイル全体を読む
2. 主要言語とフレームワークを特定
3. 以下を確認:
   - 構文エラー
   - 未使用の変数
   - 潜在的なヌルポインタ例外
   - パフォーマンスのアンチパターン

### ステップ2: フィードバックを生成
1. 以下を含む構造化されたレポートを作成:
   - 重大な問題（修正必須）
   - 警告（修正すべき）
   - 提案（あると良い）
2. 各問題について以下を提供:
   - 行番号
   - 問題の説明
   - 修正の提案
   - コード例
```

### 条件ロジックを使用

```markdown
### ステップ3: 言語固有のチェック

**Pythonの場合**:
- PEP 8準拠を確認
- 型ヒントを検証
- 一般的な落とし穴を確認（可変デフォルトなど）

**JavaScript/TypeScriptの場合**:
- ESLintルールを確認
- async/await使用を検証
- プロミス処理を確認

**Goの場合**:
- gofmt準拠を確認
- エラー処理を検証
- ゴルーチンリークを確認
```

### エッジケースを含める

```markdown
### エラー処理

**ファイルが空の場合**:
- ユーザーに警告
- テンプレートコンテンツを作成するか尋ねる
- オプションを提供

**ファイルが大きすぎる場合**（10,000行以上）:
- レビューするセクションを指定するよう依頼
- チャンクでレビューすることを提案
- 自動化ツールを提案

**言語が認識できない場合**:
- 言語を指定するよう依頼
- 一般的なレビューを試みる
- 構造パターンに焦点を当てる
```

---

## ツール使用ガイドライン

### タスク別の推奨ツール

| タスク | 推奨ツール | 避けるべき |
|------|---------------|-------|
| ファイル読み取り | `Read` | `cat`、`head`、`tail` |
| コンテンツ検索 | `Grep` | `grep`、`rg` |
| ファイル検索 | `Glob` | `find`、`ls` |
| ファイル編集 | `Edit` | `sed`、`awk` |
| ファイル作成 | `Write` | `echo >`、`cat > EOF` |
| コマンド実行 | `Bash` | （適切な使用） |
| Webリクエスト | `WebFetch` | `curl`、`wget` |

### スキルでのツール使用

**ツールを明示的に指定**:

```markdown
## 指示

### ステップ1: 設定ファイルを見つける
**Glob**ツールを使用して設定ファイルを検索:
- パターン: `**/*.config.js`
- プロジェクトルートで検索
- 一般的な場所を確認

### ステップ2: 設定を読む
**Read**ツールを使用して各設定を調べる:
- ファイル全体を読む
- JSON/YAML構造を解析
- 関連する設定を抽出
```

**特定のツールを使用する理由を説明**:

```markdown
### ツール選択

以下の場合に**Grep**を使用:
- 多くのファイルを検索する
- パターンマッチングが必要
- 出現箇所を見つけるだけで良い

以下の場合に**Read**を使用:
- 完全なコンテキストが必要
- 構造を分析する
- 関係を理解する
```

---

## テストと検証

### 作成前の検証チェックリスト

スキルを作成する前に、以下を確認：

- [ ] スキル名がユニークで説明的
- [ ] 名前がケバブケース規則に従っている
- [ ] 名前が64文字以下
- [ ] 説明が明確で具体的
- [ ] 説明にトリガーキーワードが含まれている
- [ ] 説明が200文字以下
- [ ] スキルが単一の焦点を絞った目的を持つ
- [ ] 指示が実行可能
- [ ] 例が現実的
- [ ] すべてのパスでフォワードスラッシュを使用
- [ ] YAML構文が有効
- [ ] YAMLにタブがない（スペースのみ）

### 作成後のテスト

**1. YAML検証**

```bash
# YAMLリンターを使用
yamllint SKILL.md

# またはPython
python -c "import yaml; yaml.safe_load(open('SKILL.md').read().split('---')[1])"
```

**2. インストールテスト**

```bash
# 個人用スキルディレクトリにコピー
cp -r skill-name ~/.claude/skills/

# ファイル構造を確認
ls -la ~/.claude/skills/skill-name/
```

**3. アクティベーションテスト**

スキルをトリガーすべきリクエストを試す：

- 正確なトリガーキーワードを使用
- 自然言語のバリエーションを使用
- エッジケースをテスト

**4. 機能テスト**

スキルが以下を行うことを確認：

- 期待される出力を生成
- エラーを適切に処理
- 様々な入力で動作
- 正常に完了

### 検証スクリプトテンプレート

```bash
#!/bin/bash
# validate-skill.sh

SKILL_DIR=$1

echo "スキルを検証中: $SKILL_DIR"

# 必須ファイルを確認
if [ ! -f "$SKILL_DIR/SKILL.md" ]; then
    echo "エラー: SKILL.mdが見つかりません"
    exit 1
fi

# YAML構文を確認
python3 -c "
import yaml
import sys

with open('$SKILL_DIR/SKILL.md') as f:
    content = f.read()
    parts = content.split('---')
    if len(parts) < 3:
        print('エラー: 無効なYAMLフロントマター形式')
        sys.exit(1)
    try:
        yaml.safe_load(parts[1])
        print('✓ YAML構文が有効')
    except Exception as e:
        print(f'エラー: YAMLパースに失敗: {e}')
        sys.exit(1)
"

# 必須フィールドを確認
python3 -c "
import yaml

with open('$SKILL_DIR/SKILL.md') as f:
    content = f.read()
    frontmatter = yaml.safe_load(content.split('---')[1])

    if 'name' not in frontmatter:
        print('エラー: 必須フィールドが不足: name')
        exit(1)

    if 'description' not in frontmatter:
        print('エラー: 必須フィールドが不足: description')
        exit(1)

    if len(frontmatter['name']) > 64:
        print('エラー: 名前が64文字を超えています')
        exit(1)

    if len(frontmatter['description']) > 200:
        print('エラー: 説明が200文字を超えています')
        exit(1)

    print('✓ 必須フィールドが存在し、有効です')
"

echo "✓ 検証完了"
```

---

## よくある落とし穴

### 1. 過度に広範なスキル

**問題**: スキルが多くのことをやろうとしすぎ

**例**:

```yaml
name: web-development
description: フロントエンド、バックエンド、データベース、DevOps、テスト、デプロイを含むすべてのWeb開発タスクを処理
```

**解決策**: 焦点を絞ったスキルに分割

```yaml
# より良いアプローチ
name: frontend-component-generator
description: テスト付きReact/Vueコンポーネントを生成します。UIコンポーネント作成時に使用します。

name: api-endpoint-creator
description: 検証付きREST APIエンドポイントを作成します。API構築時に使用します。
```

### 2. 曖昧な説明

**問題**: 説明がCl audeが起動タイミングを知るのに役立たない

**例**:

```yaml
description: 開発者のための便利なスキル
```

**解決策**: 具体的にする

```yaml
description: コード品質、ベストプラクティス、潜在的なバグについてプルリクエストをレビューします。PRレビュー、コードレビュー、品質チェックに使用します。キーワード: PRレビュー、コード確認。
```

### 3. 不適切なYAMLフォーマット

**問題**: スペースの代わりにタブ、区切り文字の欠落

**例**:

```yaml
# タブを使用している（見えませんがエラーの原因になります）
---
name: skill-name
  description: 不適切なフォーマット
```

**解決策**: スペースを使用し、適切な構造にする

```yaml
---
name: skill-name
description: スペースを使った適切なフォーマット
---
```

### 4. プラットフォーム固有のパス

**問題**: バックスラッシュやプラットフォーム固有のパスを使用

**例**:

```markdown
以下のファイルを確認: C:\Users\Project\src\
```

**解決策**: フォワードスラッシュを使用

```markdown
以下のファイルを確認: /project/src/
相対パスを使用: ./src/
```

### 5. 不明確な指示

**問題**: 指示が高レベルすぎる

**例**:

```markdown
## 指示
コードを分析してより良くします。
```

**解決策**: 具体的なステップを提供

```markdown
## 指示

### ステップ1: コード構造を分析
1. Readツールを使用してファイルを読む
2. 言語とフレームワークを特定
3. 関数/クラス構造をマッピング
4. 依存関係に注目

### ステップ2: 問題を確認
1. 構文エラー
2. 未使用の変数
3. 潜在的なバグ
4. パフォーマンス問題

### ステップ3: レポートを生成
1. 重要度別に問題をリスト
2. 行番号を提供
3. 具体的な修正を提案
4. コード例を含める
```

### 6. 例の欠落

**問題**: 具体的な使用例がない

**解決策**: 常に現実的な例を含める

```markdown
## 例

### 例1: 基本的なコードレビュー

**ユーザーリクエスト**: "このPythonファイルをレビューしてください"

**期待されるプロセス**:
1. ファイルを読む
2. PEP 8準拠を確認
3. 一般的なPythonの落とし穴を探す
4. 構造化されたフィードバックを生成

**期待される出力**:
```

file.pyのコードレビュー:

重大:

- 行23: ゼロ除算の可能性
- 行45: SQLインジェクション脆弱性

警告:

- 行12: 未使用のインポート 'sys'
- 行34: 変数名がPEP 8に従っていない

提案:

- 型ヒントの使用を検討
- 関数にdocstringを追加

```
```

---

## 高度なパターン

### 複数ステージスキル

明確なフェーズを持つ複雑なワークフロー用：

```markdown
## 指示

### ステージ1: 発見
[発見ステップ]

**チェックポイント**: 続行前に以下を確認:
- [ ] すべてのファイルが見つかった
- [ ] 依存関係が特定された
- [ ] 設定が有効

### ステージ2: 分析
[分析ステップ]

**チェックポイント**: 分析を検証:
- [ ] データが正しく構造化されている
- [ ] エッジケースが特定された
- [ ] 要件が明確

### ステージ3: 実行
[実行ステップ]

**最終検証**:
- [ ] 出力が要件を満たす
- [ ] エラーが発生していない
- [ ] ユーザー確認を受けた
```

### 条件付きスキル

コンテキストに基づいて分岐するスキル：

```markdown
## 指示

### ステップ1: コンテキストを検出

**Gitリポジトリ内の場合**:
- git statusを確認
- 現在のブランチを特定
- Git対応ワークフローに従う

**Gitリポジトリでない場合**:
- ファイルシステム操作を使用
- スタンドアロンワークフローに従う

### ステップ2: 言語に基づいて処理

Grepを使用して言語を検出し、その後:

**コンパイル言語**（Java、C++、Rust）の場合:
1. ビルドファイルを確認
2. コンパイルチェックを実行
3. 型チェックを実行

**インタープリタ言語**（Python、JavaScript）の場合:
1. 構文の有効性を確認
2. リンターを実行
3. テストを実行

**マークアップ言語**（HTML、Markdown）の場合:
1. 構造を検証
2. リンクを確認
3. フォーマットを検証
```

### 反復スキル

ループで動作するスキル：

```markdown
## 指示

### 反復処理

対象ディレクトリの各ファイルについて:

1. **読み取る** ファイルを
2. **分析する** 基準に従って
3. **収集する** 結果を
4. **続ける** 次のファイルへ

すべてのファイルが処理された後:

1. **集約する** 結果を
2. **ソートする** 優先度で
3. **生成する** サマリーレポート
4. **提示する** ユーザーに

### ループ制御

- 最大反復: 100ファイル
- スキップ条件: ファイルサイズ > 1MB
- 中断条件: 重大なエラーが見つかった
- 継続条件: ファイルタイプがサポートされていない
```

### メタスキル

他のスキルと連携するスキル：

```markdown
## 指示

### スキル調整

このメタスキルは複数の専門スキルを調整します:

1. **特定する** どのスキルが必要か
2. **順序付ける** スキル実行順序
3. **渡す** スキル間でコンテキストを
4. **集約する** 結果を
5. **提示する** 統一された出力を

### ワークフロー例

"コードベースを分析して改善"の場合:

1. `code-analyzer`スキルをアクティベート
2. 分析結果を収集
3. 分析を使って`code-improver`スキルをアクティベート
4. `code-tester`スキルで改善を検証
5. 最終レポートを生成

### スキル間通信

- 一貫したデータ形式を使用
- 期待される入力/出力を文書化
- スキルの失敗を適切に処理
- 必要に応じてロールバックを提供
```

---

## スキル命名規則

### 推奨パターン

| パターン | 例 | ユースケース |
|---------|---------|----------|
| `[action]-[target]` | `review-code`、`test-api` | アクション重視のスキル |
| `[domain]-[role]` | `frontend-developer`、`devops-engineer` | ロールベースのスキル |
| `[tool]-[integration]` | `docker-compose`、`git-workflow` | ツール固有のスキル |
| `[format]-[converter]` | `json-to-yaml`、`markdown-to-pdf` | 変換スキル |

### 避けるべき名前

- 一般的すぎる: `helper`、`utils`、`tools`
- 長すぎる: `comprehensive-full-stack-development-assistant`
- 数字付き: `skill-v2`、`helper-2024`
- 特殊文字付き: `skill_name`、`skill.helper`

---

## バージョン管理

### セマンティックバージョニングガイドライン

**メジャーバージョン**（1.0.0 → 2.0.0）:

- 指示フローへの破壊的変更
- 期待される入力/出力への互換性のない変更
- 機能の削除

**マイナーバージョン**（1.0.0 → 1.1.0）:

- 新機能の追加
- 新しい任意ステップ
- 機能の拡張

**パッチバージョン**（1.0.0 → 1.0.1）:

- バグ修正
- ドキュメント更新
- 小さな改善

### 変更履歴形式

```markdown
## バージョン管理

### バージョン1.2.1（2025-10-21）
- 修正: 複数行説明のYAMLパースエラー
- 更新: 最新のAPIパターンを使った例
- 改善: 不足している依存関係のエラーメッセージ

### バージョン1.2.0（2025-10-15）
- 追加: TypeScriptプロジェクトサポート
- 追加: ESLint統合
- 拡張: 大規模コードベースのパフォーマンス

### バージョン1.1.0（2025-10-01）
- 追加: Python型ヒントチェック
- 改善: エラーレポート形式

### バージョン1.0.0（2025-09-15）
- 初回リリース
- コアコードレビュー機能
```

---

このリファレンスドキュメントは、堅牢で適切に構造化されたClaude Codeスキルを作成するための包括的な技術詳細を提供します。ステップバイステップの作成プロセスについてはSKILL.mdを、すぐに使えるスタートポイントについてはtemplatesを参照してください。
