---
name: "マスタースキル"
description: "タスク分類と適切なスキル選択を行うメタスキル。タスク、分類、判断、スキル選択に関する依頼に対応"
---

# マスタースキル: タスク分類と適切なスキル選択

## このスキルを使う場面

- 新しいタスクを受け取った直後
- タスクの性質が不明確な時
- 複数のスキルが該当する可能性がある時
- 作業の方向性を決定する必要がある時

## 思考プロセス

### フェーズ1: タスクの理解と分類

**ステップ1: タスクの本質を特定する**

以下の質問に答えてタスクを分類する：

1. **何が壊れているか？** → YES なら `debugging` スキル
   - エラーメッセージがあるか
   - 期待する動作と実際の動作が異なるか
   - 既存の機能が正常に動作しないか

2. **新しいものを作るか？** → YES なら `code-creation` スキル
   - 新しい機能・コンポーネント・モジュールの作成か
   - 既存のコードベースへの機能追加か
   - ゼロからの実装が必要か

3. **既存のコードを改善するか？** → YES なら `refactoring` スキル
   - コードの品質向上が目的か
   - 構造の整理・重複の削除が必要か
   - 動作は変えずに内部実装を変更するか

4. **データを理解・分析するか？** → YES なら `data-analysis` スキル
   - データセットの探索が必要か
   - 統計的な分析・可視化が求められるか
   - パターンや傾向の発見が目的か

5. **システム全体の設計か？** → YES なら `system-design` スキル
   - アーキテクチャの決定が必要か
   - コンポーネント間の関係を定義するか
   - 技術選択・トレードオフの検討が求められるか

6. **コードをレビューするか？** → YES なら `code-review` スキル
   - 既存のコード・PR の評価が目的か
   - 品質チェック・改善提案が求められるか
   - コードの問題点を指摘する必要があるか

7. **パフォーマンスを改善するか？** → YES なら `performance-optimization` スキル
   - 速度・メモリ使用量の改善が目的か
   - ボトルネックの特定が必要か
   - 計測・プロファイリングが求められるか

8. **ドキュメントを作成するか？** → YES なら `documentation` スキル
   - 説明文書・README・API ドキュメントの作成か
   - コードの使い方を説明する必要があるか
   - 既存ドキュメントの更新・改善が目的か

**ステップ2: 複数該当する場合の優先順位**

複数のスキルが該当する場合、以下の順序で優先する：

1. **debugging** - バグがある場合は最優先で修正
2. **performance-optimization** - パフォーマンス問題は次に優先
3. **system-design** - 設計が不明確なら他の作業を始めない
4. **code-creation** - 新機能の実装
5. **refactoring** - 動作する状態を前提とした改善
6. **code-review** - レビューは他の作業と並行可能
7. **data-analysis** - 分析は情報収集として先行することも
8. **documentation** - ドキュメントは最後または並行作業

**判断基準:**

- 緊急度: 動かない > 遅い > 分かりにくい > ドキュメント不足
- 依存関係: 設計 → 実装 → リファクタリング → ドキュメント
- リスク: 高リスクなタスク（システム設計、パフォーマンス）を先に

### フェーズ2: 適切なスキルファイルの読み込み

**ステップ1: 主スキルの読み込み**

分類したタスクに対応するスキルを使用する：

- `debugging` - バグ修正・問題解決
- `code-creation` - 新規コード作成
- `refactoring` - コード改善
- `data-analysis` - データ分析・探索
- `system-design` - システム設計
- `code-review` - コードレビュー
- `performance-optimization` - パフォーマンス最適化
- `documentation` - ドキュメント作成

**ステップ2: 共通プラクティスの確認**

すべてのタスクで `shared-practices` スキルを参照する。

**ステップ3: 補助スキルの検討**

主スキルに加えて、以下の組み合わせを検討：

- **code-creation** + **system-design**: 大きな新機能の場合
- **debugging** + **code-review**: 根本原因が設計にある場合
- **refactoring** + **code-review**: リファクタリング前のレビュー
- **performance-optimization** + **debugging**: パフォーマンス問題の特定
- **すべて** + **documentation**: 作業後のドキュメント更新

### フェーズ3: 基本的な思考フレームワークの適用

すべてのタスクで以下のフレームワークを適用する：

**1. 理解フェーズ**

- 要件・問題を完全に理解する
- 不明点があればユーザーに質問する
- 前提条件を明示する

**2. 計画フェーズ**

- アプローチを決定する
- 段階を定義する
- 検証方法を決める

**3. 実行フェーズ**

- 一度に一つのステップを実行
- 各ステップ後に検証
- 問題があれば計画を修正

**4. 確認フェーズ**

- 期待通りの結果か確認
- エッジケースをチェック
- 副作用がないか検証

## 判断のポイント

### タスク分類が曖昧な場合

**質問すべき内容:**

- 「このタスクの最終的なゴールは何ですか？」
- 「現在何が問題ですか？」
- 「新しく作るものですか、既存のものを変更しますか？」

**デフォルトの選択:**

- 不明な場合は `code-creation` スキルから開始
- ただし、エラーメッセージがある場合は必ず `debugging` スキル

### 複合タスクの場合

**分解の基準:**

- タスクを独立した単位に分ける
- 各単位に適切なスキルを割り当てる
- 実行順序を決定する

**例:**
「新しい API エンドポイントを追加し、パフォーマンステストも実施」

→ 1. `system-design` (API 設計)
   2. `code-creation` (実装)
   3. `performance-optimization` (テストと最適化)

## よくある落とし穴

1. **スキルの誤分類**
   - ❌ バグ修正を `code-creation` として扱う
   - ✅ エラーがあるなら必ず `debugging`

2. **複数スキルの同時適用**
   - ❌ 設計と実装を同時に考える
   - ✅ 順序を決めて段階的に進める

3. **共通プラクティスの無視**
   - ❌ 個別スキルだけ参照する
   - ✅ 常に `shared-practices` スキルも確認

4. **早すぎる実行**
   - ❌ タスクを理解せずに作業開始
   - ✅ 分類と計画を先に完了

## 検証ポイント

### タスク分類の検証

以下を確認してタスク分類が正しいか検証：

- [ ] タスクの主目的を一文で説明できる
- [ ] 選択したスキルがその目的に合致している
- [ ] 他のスキルとの組み合わせが必要か判断した
- [ ] 実行順序が論理的である

### スキル選択の検証

- [ ] 選択したスキルの「このスキルを使う場面」に該当する
- [ ] 必要な補助スキルを特定した
- [ ] `shared-practices` スキルの確認を予定している

## 他スキルとの連携

### 必須の連携

- **shared-practices**: すべてのタスクで参照必須

### 推奨される連携

- **debugging** → **code-review**: バグの根本原因が設計の場合
- **system-design** → **code-creation**: 大規模な新機能の場合
- **refactoring** → **code-review**: リファクタリング前後の品質確認
- **performance-optimization** → **debugging**: パフォーマンス問題の原因特定

### 順序が重要な連携

1. **system-design** → その他すべて: 設計が不明確なら先に設計
2. **debugging** → **refactoring**: バグを直してから改善
3. **code-creation/refactoring** → **documentation**: 実装後にドキュメント更新

## タスク開始時のチェックリスト

すべてのタスクで以下を確認してから作業開始：

- [ ] タスクの分類が完了した
- [ ] 適切なスキルを特定した
- [ ] `shared-practices` スキルを参照する予定である
- [ ] 補助スキルの必要性を検討した
- [ ] 実行順序を決定した（複合タスクの場合）
- [ ] 不明点をユーザーに確認した（必要な場合）

## 特殊なケースの処理

### 探索的タスク

「このコードベースについて教えて」のような探索的タスクの場合：

1. まず `code-review` スキルで全体を把握
2. 必要に応じて `data-analysis` スキルでメトリクス分析
3. `documentation` スキルで既存ドキュメントを確認

### 緊急のバグ修正

本番環境の問題など緊急性が高い場合：

1. **即座に** `debugging` スキルを適用
2. `shared-practices` スキルの「エラーからの回復戦略」を参照
3. 修正後に `code-review` スキルで根本原因を分析

### 大規模なリファクタリング

システム全体に影響する大規模な変更の場合：

1. `system-design` スキルで影響範囲とアプローチを設計
2. `refactoring` スキルで段階的な変更計画を立案
3. `code-review` スキルで各段階をレビュー
4. `documentation` スキルでアーキテクチャドキュメントを更新
