---
name: "generic-subagent"
description: >
  任意のタスクを別セッションで実行し、メインセッションのコンテキストウィンドウを節約します。
  別セッション実行、コンテキスト節約、サブエージェント実行、タスク委任、セッション分離が必要な時に使用します。
  キーワード - 別セッション、コンテキスト節約、独立実行、タスク分離、サブエージェント。
version: 1.0.0
---

# 汎用サブエージェント実行スキル

## 目的

このスキルは、どんなタスクでも別セッションで実行することで、メインセッションのコンテキストウィンドウを節約します。長いタスク、複雑なタスク、または現在のコンテキストを汚染したくないタスクに最適です。

## このスキルを使用するタイミング

以下の場合にこのスキルを使用します：

- ユーザーが「別セッションで実行して」と依頼
- コンテキストウィンドウを節約したい
- 長時間かかるタスクをバックグラウンドで実行
- 現在の会話コンテキストから独立してタスクを実行
- メインセッションを軽量に保ちたい

## 基本原則

### サブエージェントの特性

1. **完全独立**: 別のコンテキストウィンドウで動作
2. **ステートレス**: 現在の会話履歴にアクセスしない
3. **自律的**: 追加の指示なしで完全に自己完結
4. **効率的**: メインセッションのトークンを消費しない

### コンテキスト節約の仕組み

- サブエージェントは独自のコンテキストウィンドウを使用
- メインセッションには要約された結果のみが返される（1,000-2,000トークン程度）
- 詳細な実行過程はメインセッションのコンテキストに含まれない

## 実行プロセス

### ステップ1: タスクの受け取りと明確化

ユーザーから実行したいタスクを受け取ります。不明確な場合は以下を確認：

1. **タスクの目的**: 何を達成したいか
2. **期待する成果物**: どのような結果が欲しいか
3. **制約条件**: 除外すべきものや注意事項

### ステップ2: 適切なサブエージェントタイプの自動選択

タスク内容に基づいて最適なサブエージェントタイプを選択：

**general-purpose を選択する場合**:
- ファイルの作成・編集が必要
- Web検索（WebSearch）が必要
- Web取得（WebFetch）が必要
- 包括的な実装タスク
- 複雑なマルチステップタスク

**Explore を選択する場合**:
- コードベースの探索のみ
- ファイル検索（パターンマッチング）
- キーワードによるコード検索
- 読み取り専用のリサーチタスク
- 高速な調査が必要

**選択基準**:
- ファイル書き込みが必要 → general-purpose
- Web調査が必要 → general-purpose
- 探索・検索のみ → Explore（高速）
- 不明な場合 → general-purpose（安全策）

### ステップ3: 詳細なタスク記述の作成

サブエージェントが自律的に動作できるよう、明確で詳細なタスク記述を作成：

**タスク記述に含めるべき内容**:

1. **明確な目的**:
   ```
   タスク: [タスク名]

   目的:
   [何を達成する必要があるか具体的に記述]
   ```

2. **具体的な手順**（複雑なタスクの場合）:
   ```
   手順:
   1. [ステップ1の詳細]
   2. [ステップ2の詳細]
   3. [ステップ3の詳細]
   ```

3. **期待される成果物**:
   ```
   期待される成果物:
   - [成果物1]
   - [成果物2]
   - [報告形式の指定]
   ```

4. **制約・注意事項**:
   ```
   制約:
   - [除外すべきもの]
   - [特別な注意事項]
   ```

5. **必要なコンテキスト**:
   ```
   コンテキスト:
   [背景情報や関連情報]
   ```

### ステップ4: サブエージェントの起動

Taskツールを使用してサブエージェントを起動：

```
Task tool parameters:
- description: "[3-5単語の簡潔な説明]"
- subagent_type: "general-purpose" または "Explore"
- prompt: [ステップ3で作成した詳細なタスク記述]
```

### ステップ5: 結果の取得と報告

サブエージェントの実行完了後、結果を要約してユーザーに報告：

**報告内容**:
1. 実行したタスクの概要
2. 主要な発見・成果
3. 具体的な結果（ファイルパス、行番号等を含む）
4. 推奨される次のステップ

**報告例**:
```
別セッションでのタスク実行完了

タスク: [タスク名]
サブエージェントタイプ: [使用したタイプ]

主要な結果:
- [結果1]
- [結果2]
- [結果3]

詳細:
[必要に応じて詳細情報]

次のステップ:
[推奨されるフォローアップアクション]
```

## ベストプラクティス

### タスク設計

1. **自己完結性**: すべての必要情報をタスク記述に含める
2. **明確性**: 曖昧な表現を避け、具体的に記述
3. **完全性**: サブエージェントが追加質問できないことを考慮

### サブエージェントタイプ選択

1. **Explore優先**: 読み取り専用タスクには高速なExploreを使用
2. **必要十分**: タスクに必要な最小限のツールセットを持つタイプを選択
3. **安全策**: 不明な場合はgeneral-purposeを選択

### コンテキスト管理

1. **要約重視**: サブエージェントの詳細な結果を簡潔に要約
2. **重要情報の抽出**: ユーザーに本当に必要な情報のみを報告
3. **透明性**: 何が実行されたかをユーザーに明確に伝える

## 使用例

### 例1: コードベース探索を別セッションで実行

**ユーザーリクエスト**: "このプロジェクトのAPI定義を別セッションで調べて"

**実行フロー**:

1. タスクの明確化:
   - 目的: APIエンドポイントの定義場所と方法を特定
   - サブエージェントタイプ: Explore（読み取り専用）

2. タスク記述の作成:
   ```
   タスク: APIエンドポイント定義の調査

   目的:
   プロジェクト内でAPIエンドポイントがどのように定義され実装されているかを特定してください。

   手順:
   1. ルーティング関連のファイルを検索（routes, api, endpoints等）
   2. HTTPメソッド定義を探す（GET, POST, PUT, DELETE）
   3. 使用されているフレームワークを特定
   4. エンドポイントパターンを分析

   期待される成果物:
   - エンドポイント定義ファイルのリスト（パス付き）
   - 使用フレームワーク/ライブラリ
   - 主要エンドポイントの例（3-5個）

   制約:
   - node_modules/と.git/を除外
   - テストファイルは別途記載
   ```

3. サブエージェント起動:
   - description: "APIエンドポイント定義調査"
   - subagent_type: "Explore"
   - prompt: [上記のタスク記述]

4. 結果報告:
   ```
   別セッションでのAPI調査完了

   主要な発見:
   - Express.jsを使用
   - エンドポイント定義: src/routes/ディレクトリ
   - 主要ファイル:
     - src/routes/api/users.ts:10-45 (ユーザー関連)
     - src/routes/api/posts.ts:8-62 (投稿関連)
   - RESTfulパターンに従った構造

   次のステップ:
   特定のエンドポイントについて詳しく調査することも可能です。
   ```

### 例2: 実装タスクを別セッションで実行

**ユーザーリクエスト**: "新しいユーティリティ関数を別セッションで作成して"

**実行フロー**:

1. タスクの明確化:
   - 目的: ユーティリティ関数の実装
   - サブエージェントタイプ: general-purpose（ファイル書き込み必要）

2. タスク記述の作成:
   ```
   タスク: 日付フォーマットユーティリティ関数の作成

   目的:
   日付を様々な形式でフォーマットするユーティリティ関数を作成してください。

   手順:
   1. src/utils/ディレクトリを確認
   2. dateUtils.tsファイルを作成または編集
   3. formatDate関数を実装
   4. JSDocコメントを追加
   5. 簡単な使用例をコメントで記載

   期待される成果物:
   - 実装された関数のファイルパス
   - 関数のシグネチャ
   - サポートするフォーマット一覧

   制約:
   - TypeScriptで実装
   - 既存のコーディング規約に従う
   - 外部ライブラリは使用しない（標準APIのみ）
   ```

3. サブエージェント起動:
   - description: "日付ユーティリティ関数作成"
   - subagent_type: "general-purpose"
   - prompt: [上記のタスク記述]

4. 結果報告:
   ```
   別セッションでの実装完了

   作成ファイル:
   - src/utils/dateUtils.ts

   実装内容:
   - formatDate(date: Date, format: string): string
   - サポートフォーマット: 'YYYY-MM-DD', 'MM/DD/YYYY', 'DD/MM/YYYY'
   - JSDocコメント付き

   次のステップ:
   1. テストの作成
   2. 他のモジュールからの利用
   ```

### 例3: Web調査を別セッションで実行

**ユーザーリクエスト**: "最新のReact 19の機能を別セッションで調査して"

**実行フロー**:

1. タスクの明確化:
   - 目的: React 19の新機能調査
   - サブエージェントタイプ: general-purpose（WebSearch必要）

2. タスク記述の作成:
   ```
   タスク: React 19新機能の調査

   目的:
   React 19の新機能を調査し、主要な変更点をまとめてください。

   手順:
   1. 公式ドキュメントをWebSearchで検索
   2. 主要な新機能をリストアップ
   3. 各機能の利点と使用例を調査
   4. ブレイキングチェンジを確認

   期待される成果物:
   - 新機能リスト（簡潔な説明付き）
   - ブレイキングチェンジの一覧
   - 移行時の注意点

   制約:
   - 公式ドキュメントまたは信頼できる情報源を優先
   - 実験的機能は別途記載
   ```

3. サブエージェント起動:
   - description: "React 19新機能調査"
   - subagent_type: "general-purpose"
   - prompt: [上記のタスク記述]

4. 結果報告:
   ```
   別セッションでのReact 19調査完了

   主要な新機能:
   1. React Compiler（自動メモ化）
   2. Server Components の改善
   3. Actions の正式サポート
   4. Document Metadata の組み込みサポート

   ブレイキングチェンジ:
   - レガシーContext APIの非推奨化
   - いくつかのライフサイクルメソッドの削除

   次のステップ:
   1. プロジェクトの互換性確認
   2. 段階的な移行計画の立案
   ```

## エラー処理

### タスクが不明確な場合

ユーザーに具体的な質問をする：

```
タスクの内容をもう少し具体的に教えていただけますか？

以下の情報があると助かります：
1. 何を達成したいですか？
2. どのような結果が欲しいですか？
3. 特別な制約や注意事項はありますか？
```

### サブエージェントが失敗した場合

1. エラーメッセージを分析
2. タスク記述を調整して再実行
3. 必要に応じてタスクを分割

```
サブエージェントの実行中にエラーが発生しました。
タスクを調整して再実行しますか？

または、以下のように分割することも可能です：
1. [サブタスク1]
2. [サブタスク2]
```

### 結果が期待と異なる場合

タスク記述を改善して再実行を提案：

```
結果が期待と異なるようです。
タスク記述を以下のように更新して再実行しましょうか？

更新案:
[改善されたタスク記述]
```

## 重要な注意事項

### 実行時の制約

1. **完全自律**: サブエージェントは追加の指示を受け取れない
2. **ステートレス**: 現在の会話履歴にアクセスできない
3. **自己完結**: すべての情報をタスク記述に含める必要がある

### ユーザーとのコミュニケーション

1. **透明性**: 何が実行されているか明確に伝える
2. **要約**: 詳細な実行過程ではなく、重要な結果のみを報告
3. **次のステップ**: フォローアップアクションを提案

### 品質保証

1. **タスク記述の検証**: 起動前に自己完結性を確認
2. **結果の評価**: サブエージェントの出力を批判的に評価
3. **柔軟性**: 期待と異なる結果の場合は調整

## サブエージェントテンプレートの使用方法

このスキルには、サブエージェント自体の定義とタスク呼び出しテンプレートが含まれています。

### 利用可能なテンプレート

1. **`templates/generic-subagent-prompt.md`**:
   - サブエージェント自体の完全な定義
   - 別セッションで実行されるサブエージェントの行動指針
   - タスク実行プロセス、ツール使用ガイドライン、報告フォーマット等を含む

2. **`templates/task-invocation-template.md`**:
   - Taskツールでサブエージェントを呼び出すための参考テンプレート
   - 様々なタスクタイプ別の呼び出し例
   - タスク記述のベストプラクティス

### 実際の使用方法

サブエージェントを起動する際は、以下の構造でTaskツールを使用します：

```
Task tool parameters:
- description: "[3-5単語の簡潔な説明]"
- subagent_type: "general-purpose" または "Explore"
- prompt: [以下の構造のプロンプト]
```

**プロンプトの構造**:

```markdown
[templates/generic-subagent-prompt.mdの全内容をここに含める]

---

## タスク記述

### タスク概要
[タスク名と目的]

### 目的
[何を達成する必要があるか]

### 手順（複雑なタスクの場合）
1. [ステップ1]
2. [ステップ2]
3. [ステップ3]

### 期待される成果物
- [成果物1]
- [成果物2]

### 制約・注意事項
- [制約1]
- [制約2]

### コンテキスト（必要な場合）
[背景情報]
```

### テンプレートの読み込み

実装時は、以下の手順でテンプレートを使用：

1. **テンプレートファイルの読み込み**:
   ```
   Read tool: templates/generic-subagent-prompt.md
   ```

2. **タスク記述の作成**:
   ユーザーの要求に基づいて具体的なタスク記述を作成

3. **プロンプトの結合**:
   テンプレート内容 + タスク記述を結合

4. **Taskツールの呼び出し**:
   結合したプロンプトでサブエージェントを起動

### 実装例

```
1. Read: templates/generic-subagent-prompt.md を読み込む
2. ユーザーから「APIエンドポイントを調査して」というリクエストを受け取る
3. タスク記述を作成:
   - 目的: APIエンドポイントの定義場所と方法を特定
   - 手順: ファイル検索、フレームワーク特定、パターン分析
   - 期待される成果物: ファイルリスト、フレームワーク名、具体例
4. テンプレート内容 + タスク記述を結合
5. Task tool を呼び出し:
   - description: "APIエンドポイント定義調査"
   - subagent_type: "Explore"
   - prompt: [結合したプロンプト]
6. 結果を受け取り、ユーザーに要約して報告
```

### 重要なポイント

1. **テンプレートの完全性**: サブエージェントが自律的に動作できるよう、generic-subagent-prompt.mdの全内容を含める

2. **タスク記述の詳細性**: サブエージェントは追加質問できないため、タスク記述に必要な情報をすべて含める

3. **期待する成果物の明示**: どのような形式で結果が欲しいかを具体的に指定

4. **制約の明確化**: 除外すべきもの、特別な注意事項を明記

詳細な使用例と様々なタスクタイプ別のテンプレートは、`templates/task-invocation-template.md` および `examples.md` を参照してください。

## 参考情報

- Claude Code公式ドキュメント: https://docs.claude.com/en/docs/claude-code
- サブエージェント詳細: https://docs.claude.com/en/docs/claude-code/sub-agents
- テンプレートファイル: `templates/generic-subagent-prompt.md`, `templates/task-invocation-template.md`
- 使用例集: `examples.md`
