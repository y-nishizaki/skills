# 汎用サブエージェント実行スキル - 使用例集

このドキュメントでは、汎用サブエージェント実行スキルの様々な使用シナリオと実例を紹介します。

## 目次

1. [基本的な使用例](#基本的な使用例)
2. [コードベース探索](#コードベース探索)
3. [実装タスク](#実装タスク)
4. [調査・リサーチタスク](#調査リサーチタスク)
5. [複雑なマルチステップタスク](#複雑なマルチステップタスク)
6. [並列実行の活用](#並列実行の活用)

## 基本的な使用例

### 例1: シンプルなファイル検索

**ユーザー**: "別セッションでTypeScriptの設定ファイルを全部見つけて"

**Claude（このスキル起動時）**:

```
別セッションでTypeScript設定ファイルの検索を実行します。

タスク記述:
- 目的: プロジェクト内のTypeScript設定ファイルを全て検索
- サブエージェントタイプ: Explore（ファイル検索に最適）
```

**実行後の報告**:

```
別セッションでの検索完了

発見された設定ファイル:
- tsconfig.json（ルート）
- tsconfig.build.json
- packages/frontend/tsconfig.json
- packages/backend/tsconfig.json
- tests/tsconfig.json

各ファイルの役割:
- ルートのtsconfig.json: 共通設定の基盤
- tsconfig.build.json: ビルド時の設定
- パッケージ別: モジュール固有の設定オーバーライド
```

### 例2: 特定パターンのコード検索

**ユーザー**: "useEffectの使い方が正しくない箇所を別セッションで探して"

**Claude（このスキル起動時）**:

```
別セッションでuseEffectの問題箇所を検索します。

タスク記述:
- 目的: useEffectの不適切な使用パターンを特定
- サブエージェントタイプ: Explore
- 検索対象: 依存配列の問題、無限ループの可能性等
```

**実行後の報告**:

```
別セッションでの分析完了

検出された問題箇所:

【高優先度】3件
1. src/components/Dashboard.tsx:45
   - 問題: useEffectの依存配列が空だが、関数内でpropsを使用
   - 推奨: propsを依存配列に追加

2. src/hooks/useData.ts:28
   - 問題: useEffect内でstateを更新し、そのstateが依存配列に含まれる
   - 推奨: 無限ループの可能性、ロジックの見直しが必要

3. src/pages/UserProfile.tsx:67
   - 問題: 非同期関数を直接useEffectに渡している
   - 推奨: 内部で非同期関数を定義して呼び出す

【中優先度】5件
（以下、同様に問題箇所をリスト）

次のステップ:
高優先度の問題から順に修正していきましょうか？
```

## コードベース探索

### 例3: アーキテクチャパターンの調査

**ユーザー**: "このプロジェクトの状態管理の仕組みを別セッションで調べて"

**Claude（このスキル起動時）**:

```
別セッションでプロジェクトの状態管理パターンを調査します。

タスク記述の詳細:
---
タスク: 状態管理パターンの包括的調査

目的:
プロジェクト内で使用されている状態管理の方法、ライブラリ、
パターンを特定し、その使用箇所と構造を分析してください。

手順:
1. 状態管理関連のインポート文を検索（useState, useContext, Redux, Zustand等）
2. ストア定義ファイルを特定
3. グローバル状態とローカル状態の使い分けを分析
4. 状態更新パターンを確認

期待される成果物:
- 使用されている状態管理ライブラリ一覧
- グローバル状態の定義箇所
- 主要な状態フローの説明
- パターンの一貫性評価

制約:
- node_modules/を除外
- テストファイルは参考程度に
---
```

**実行後の報告**:

```
別セッションでの状態管理調査完了

使用されている状態管理:

【グローバル状態】
- Zustand: メインの状態管理ライブラリ
  - ストア定義: src/stores/
    - userStore.ts（ユーザー情報）
    - appStore.ts（アプリケーション設定）
    - dataStore.ts（キャッシュデータ）

【ローカル状態】
- useState: コンポーネント固有の状態
  - 主な使用箇所: フォーム入力、UI状態、一時的な表示制御

【Context API】
- ThemeContext: テーマの切り替え（src/contexts/ThemeContext.tsx）
- AuthContext: 認証状態（src/contexts/AuthContext.tsx）

構造の評価:
✓ グローバル/ローカルの使い分けが適切
✓ ストアが責務ごとに分離されている
△ 一部のコンポーネントで状態が過度にネストしている

推奨事項:
1. 複雑なローカル状態はuseReducerへの移行を検討
2. ストアのTypeScript型定義の強化
```

### 例4: 依存関係の分析

**ユーザー**: "このモジュールがどこから使われているか別セッションで調べて"

**Claude（このスキル起動時）**:

```
別セッションで指定モジュールの使用箇所を調査します。

タスク記述:
---
タスク: モジュール依存関係の分析

目的:
src/utils/apiClient.ts がプロジェクト内でどのように使用されているかを
特定してください。

手順:
1. apiClient のインポート文を全検索
2. 各使用箇所でどのように呼び出されているか確認
3. 依存関係ツリーを構築
4. 頻繁に使用されるパターンを特定

期待される成果物:
- インポートしているファイルの一覧（パス付き）
- 主な使用パターン
- 依存関係の深さ
- 循環依存の有無

制約:
- node_modules/を除外
- 型定義ファイル（.d.ts）も含める
---
```

**実行後の報告**:

```
別セッションでの依存関係分析完了

apiClient の使用状況:

【直接使用】15箇所
主要な使用箇所:
- src/services/userService.ts:3（GET/POST/DELETE）
- src/services/postService.ts:5（CRUD操作）
- src/hooks/useApi.ts:12（カスタムフック経由）
- src/pages/api/proxy.ts:8（プロキシ経由）

【間接使用】43箇所
- useApi カスタムフック経由: 38箇所
- userService 経由: 3箇所
- postService 経由: 2箇所

使用パターン:
1. 直接呼び出し（31%）
   例: apiClient.get('/users')

2. サービス層経由（27%）
   例: userService.getUser(id)

3. カスタムフック経由（42%）
   例: useApi('/users')

依存関係の評価:
✓ 循環依存なし
✓ サービス層での適切な抽象化
△ 一部のコンポーネントで直接呼び出しあり

推奨事項:
直接呼び出しをサービス層またはフック経由に統一することで
メンテナンス性が向上します。
```

## 実装タスク

### 例5: ユーティリティ関数の作成

**ユーザー**: "配列をチャンクに分割する関数を別セッションで作って"

**Claude（このスキル起動時）**:

```
別セッションで配列チャンク分割関数を実装します。

タスク記述:
---
タスク: 配列チャンク分割ユーティリティ関数の実装

目的:
配列を指定されたサイズのチャンクに分割する汎用関数を作成してください。

要件:
1. TypeScriptで実装
2. ジェネリック型を使用して型安全性を確保
3. エッジケースを処理（空配列、チャンクサイズ0等）
4. JSDocコメントを追加
5. 使用例をコメントで記載

実装場所:
- src/utils/arrayUtils.ts（既存ファイルがあれば追記、なければ新規作成）

期待される成果物:
- 実装されたファイルのパス
- 関数のシグネチャ
- 簡単な使用例
---
```

**実行後の報告**:

```
別セッションでの実装完了

作成ファイル: src/utils/arrayUtils.ts

実装内容:
```typescript
/**
 * 配列を指定されたサイズのチャンクに分割します
 * @param array 分割する配列
 * @param chunkSize チャンクのサイズ
 * @returns チャンクに分割された配列
 */
export function chunk<T>(array: T[], chunkSize: number): T[][] {
  if (chunkSize <= 0) {
    throw new Error('Chunk size must be greater than 0');
  }

  const result: T[][] = [];
  for (let i = 0; i < array.length; i += chunkSize) {
    result.push(array.slice(i, i + chunkSize));
  }
  return result;
}

// 使用例:
// const numbers = [1, 2, 3, 4, 5, 6, 7];
// const chunks = chunk(numbers, 3);
// // => [[1, 2, 3], [4, 5, 6], [7]]
```

次のステップ:

1. ユニットテストの作成
2. 他の配列ユーティリティ関数の追加検討

```

### 例6: コンポーネントの作成

**ユーザー**: "ローディングスピナーコンポーネントを別セッションで作って"

**Claude（このスキル起動時）**:

```

別セッションでローディングスピナーコンポーネントを実装します。

#### タスク: ローディングスピナーの作成

目的:
再利用可能なローディングスピナーコンポーネントをReactで作成してください。

要件:

1. TypeScript + React
2. サイズのバリエーション（small, medium, large）
3. カラーのカスタマイズ対応
4. アクセシビリティ対応（ARIA属性）
5. CSS-in-JS または CSS Modules

実装場所:

- src/components/LoadingSpinner/
  - LoadingSpinner.tsx
  - LoadingSpinner.module.css（スタイル）
  - index.ts（エクスポート）

期待される成果物:

- 実装されたファイル一覧
- コンポーネントのProps型定義
- 簡単な使用例

---

```

**実行後の報告**:

```

別セッションでのコンポーネント実装完了

作成ファイル:

- src/components/LoadingSpinner/LoadingSpinner.tsx
- src/components/LoadingSpinner/LoadingSpinner.module.css
- src/components/LoadingSpinner/index.ts

Props型定義:

```typescript
interface LoadingSpinnerProps {
  size?: 'small' | 'medium' | 'large';
  color?: string;
  className?: string;
}
```

使用例:

```tsx
import { LoadingSpinner } from '@/components/LoadingSpinner';

// 基本的な使用
<LoadingSpinner />

// カスタマイズ
<LoadingSpinner size="large" color="#3b82f6" />
```

実装の特徴:

- CSS Animationによる滑らかな回転
- アクセシビリティ: role="status", aria-live="polite"
- レスポンシブ対応
- カスタムカラー対応

次のステップ:

1. Storybookへの追加
2. 使用箇所での置き換え

```

## 調査・リサーチタスク

### 例7: ライブラリのベストプラクティス調査

**ユーザー**: "Next.js 15の新機能を別セッションで調べて"

**Claude（このスキル起動時）**:

```

別セッションでNext.js 15の新機能を調査します。

#### タスク: Next.js 15の新機能調査

目的:
Next.js 15の新機能、変更点、ブレイキングチェンジを調査し、
このプロジェクトへの適用可能性を評価してください。

手順:

1. 公式ドキュメントをWebSearchで検索
2. 主要な新機能をリストアップ
3. ブレイキングチェンジを確認
4. 現在のプロジェクト（package.jsonを確認）との互換性評価
5. 移行時の注意点をまとめる

期待される成果物:

- 新機能リスト（各機能の説明付き）
- ブレイキングチェンジ一覧
- プロジェクトへの影響評価
- 移行手順の概要

制約:

- 公式ドキュメントを優先
- 信頼できる技術ブログも参考可
- 実験的機能は明示的に区別

---

```

**実行後の報告**:

```

別セッションでのNext.js 15調査完了

主要な新機能:

1. Turbopack Stable（安定版）
   - 説明: Webpackの代替、高速ビルド
   - 影響: ビルド時間が大幅に短縮される可能性
   - 適用可能性: 高（すぐに試せる）

2. Partial Prerendering
   - 説明: 静的部分と動的部分を組み合わせた新しいレンダリング戦略
   - 影響: パフォーマンス向上
   - 適用可能性: 中（段階的に導入）

3. Server Actions の改善
   - 説明: フォーム処理の簡素化、型安全性の向上
   - 影響: コード量削減、DX向上
   - 適用可能性: 高（新規機能から採用）

ブレイキングチェンジ:

1. Node.js 18.17以上が必須
   - 現在のプロジェクト: 18.12使用中
   - 対応: Node.jsのアップグレードが必要

2. next/imageのデフォルト動作変更
   - 影響: 既存の画像最適化設定の見直しが必要
   - 対応: next.config.jsの調整

3. App Routerがデフォルト
   - 影響: Pages Routerは引き続きサポートされるが推奨されない
   - 対応: 新規ページはApp Routerで作成

移行の優先順位:

【フェーズ1】即座に実施可能

- Node.jsのアップグレード（18.17+）
- Turbopackの試験的導入（next dev --turbo）

【フェーズ2】段階的に導入

- 新規ページをApp Routerで作成
- Server Actionsの活用

【フェーズ3】長期的な取り組み

- Pages RouterからApp Routerへの完全移行
- Partial Prerenderingの最適化

次のステップ:

1. Node.jsバージョンの確認・アップグレード
2. Turbopackでの開発ビルドテスト
3. 移行計画の詳細化

```

### 例8: セキュリティ監査

**ユーザー**: "セキュリティ上の問題がないか別セッションでチェックして"

**Claude（このスキル起動時）**:

```

別セッションでセキュリティ監査を実行します。

#### タスク: セキュリティ脆弱性の検出

目的:
プロジェクト内の一般的なセキュリティ問題を特定してください。

チェック項目:

1. ハードコードされたシークレット（APIキー、パスワード等）
2. SQL injection の可能性
3. XSS脆弱性の可能性
4. 不適切な認証・認可実装
5. 安全でない依存関係の使用

手順:

1. .envファイルがgitignoreされているか確認
2. コード内のシークレット文字列を検索
3. データベースクエリの構築方法を確認
4. ユーザー入力の処理とサニタイゼーションを確認
5. 認証関連コードのレビュー

期待される成果物:

- 検出された問題のリスト（深刻度別）
- 各問題の具体的な箇所（ファイル:行番号）
- 修正方法の推奨事項

制約:

- node_modules/を除外
- テストコードは参考程度に

---

```

**実行後の報告**:

```

別セッションでのセキュリティ監査完了

検出された問題:

【高】Critical - 2件

1. ハードコードされたAPIキー
   場所: src/config/api.ts:5
   問題: `const API_KEY = "sk-1234567890abcdef"`
   推奨: 環境変数に移動（process.env.API_KEY）

2. SQLインジェクションの可能性
   場所: src/db/queries.ts:23
   問題: 文字列結合でSQLクエリを構築
   推奨: パラメータ化クエリの使用

【中】Medium - 5件

3. XSS脆弱性の可能性
   場所: src/components/Comment.tsx:45
   問題: dangerouslySetInnerHTMLの使用
   推奨: サニタイゼーションライブラリ（DOMPurify等）の使用

4. 弱いパスワードポリシー
   場所: src/utils/validation.ts:12
   問題: 最小6文字のみの制限
   推奨: 複雑性要件の追加（大小文字、数字、記号）

5. セッショントークンが localStorage に保存
   場所: src/utils/auth.ts:34
   問題: XSS攻撃でトークンが盗まれる可能性
   推奨: httpOnly cookieの使用

【低】Low - 3件

6. console.log に機密情報
   場所: src/services/authService.ts:67
   問題: ユーザー情報をコンソールに出力
   推奨: 本番環境では削除

（他2件も同様にリスト）

推奨される対応順:

1. 【即座】ハードコードされたシークレットの削除
2. 【即座】SQLインジェクション対策
3. 【1週間以内】XSS対策とトークン保存方法の変更
4. 【2週間以内】パスワードポリシーの強化
5. 【継続的】コンソールログのクリーンアップ

次のステップ:
高優先度の問題から順に修正していきましょうか？
詳細な修正方法が必要な場合はお知らせください。

```

## 複雑なマルチステップタスク

### 例9: リファクタリング計画

**ユーザー**: "このモジュールのリファクタリング計画を別セッションで立てて"

**Claude（このスキル起動時）**:

```

別セッションでリファクタリング計画を作成します。

#### タスク: モジュールリファクタリング計画の策定

目的:
src/services/userService.ts のリファクタリング計画を立案してください。
現在の問題点を特定し、改善案を提案してください。

分析項目:

1. コードの複雑度（関数の長さ、ネスト深度）
2. 責務の分離状況
3. テスト容易性
4. エラー処理の一貫性
5. TypeScript型の活用度
6. 依存関係の複雑さ

手順:

1. 対象ファイルを詳細に分析
2. 問題点を特定（具体的な行番号付き）
3. 改善案を提案
4. リファクタリングの優先順位を決定
5. 段階的な実施計画を作成

期待される成果物:

- 現状分析レポート
- 検出された問題点一覧
- 具体的な改善案
- 段階的リファクタリング計画
- 各フェーズの所要時間見積もり

---

```

**実行後の報告**:

```

別セッションでのリファクタリング計画策定完了

現状分析:

ファイル: src/services/userService.ts
総行数: 456行
関数数: 12
平均関数長: 38行（推奨: <20行）

検出された問題点:

【設計上の問題】

1. 単一責任原則違反
   - ユーザーデータ取得、変換、検証、キャッシュ管理が混在
   - 推奨: 責務ごとにモジュール分割

2. 関数の肥大化
   - getUserProfile(): 87行（src/services/userService.ts:45-132）
   - updateUserData(): 63行（src/services/userService.ts:134-197）
   - 推奨: 小さな関数に分割

【型安全性の問題】
3. any型の多用

- 12箇所でany型を使用
- 推奨: 適切な型定義の作成

4. 型ガードの不足
   - APIレスポンスの型チェックなし
   - 推奨: zodやio-tsによるランタイム検証

【エラー処理の問題】
5. 一貫性のないエラー処理

- try-catchとPromise.catch()が混在
- 推奨: 統一されたエラー処理戦略

リファクタリング計画:

【フェーズ1】準備（1-2日）

- テストカバレッジの確認・向上
- 型定義の整備
- 期待動作のドキュメント化

【フェーズ2】構造改善（3-5日）

- 責務の分離
  - userRepository.ts（データアクセス層）
  - userValidator.ts（検証ロジック）
  - userTransformer.ts（データ変換）
  - userCache.ts（キャッシュ管理）
- 大きな関数の分割

【フェーズ3】型安全性向上（2-3日）

- any型の排除
- Zod schemaの導入
- APIレスポンス型の厳密化

【フェーズ4】エラー処理統一（1-2日）

- カスタムエラークラスの作成
- エラー処理の統一
- エラーログの改善

【フェーズ5】最適化（2-3日）

- パフォーマンス改善
- 不要なAPI呼び出しの削減
- キャッシュ戦略の最適化

総所要時間見積もり: 9-15日

リスク評価:

- 低: 十分なテストがある部分
- 中: 複雑なビジネスロジック
- 高: テストが不足している部分

推奨アプローチ:
段階的リファクタリング（Strangler Fig Pattern）を使用し、
既存機能を壊さずに徐々に改善していく。

次のステップ:

1. フェーズ1から開始しますか？
2. 特定の問題に焦点を当てますか？
3. 詳細な実装計画が必要ですか？

```

## 並列実行の活用

### 例10: 複数モジュールの同時分析

**ユーザー**: "フロントエンドとバックエンドのコード品質を別セッションで同時にチェックして"

**Claude（このスキル起動時）**:

```

2つのサブエージェントを並列実行してコード品質をチェックします。

【サブエージェント1】フロントエンドの品質チェック

#### タスク: フロントエンド品質分析

目的:
src/frontend/ 配下のReactコードの品質を評価してください。

チェック項目:

1. コンポーネント設計の品質
2. hooks の適切な使用
3. パフォーマンス問題
4. アクセシビリティ
5. コーディング規約の遵守

期待される成果物:

- 品質スコア（1-10）
- 検出された問題一覧
- 改善推奨事項

---

【サブエージェント2】バックエンドの品質チェック

#### タスク: バックエンド品質分析

目的:
src/backend/ 配下のNode.jsコードの品質を評価してください。

チェック項目:

1. API設計の品質
2. エラーハンドリング
3. セキュリティ
4. データベースクエリの効率
5. コーディング規約の遵守

期待される成果物:

- 品質スコア（1-10）
- 検出された問題一覧
- 改善推奨事項

---

並列実行中...

```

**実行後の報告**:

```

並列セッションでのコード品質チェック完了

【フロントエンド分析結果】

品質スコア: 7.5/10

良い点:
✓ モダンなReact hooks を適切に使用
✓ コンポーネントの再利用性が高い
✓ TypeScriptの型定義が充実

改善点:
△ 一部の大きなコンポーネント（5個）
△ アクセシビリティ対応が不十分（12箇所）
△ パフォーマンス最適化の余地あり（8箇所）

主要な問題:

1. src/components/DataTable.tsx（234行）
   - 問題: コンポーネントが大きすぎる
   - 推奨: 小さなコンポーネントに分割

2. src/pages/Dashboard.tsx:89
   - 問題: useEffectの依存配列の問題
   - 推奨: 依存配列の修正

3. アクセシビリティ
   - 12箇所でaria属性が不足
   - ボタンにアクセシブルな名前が必要

【バックエンド分析結果】

品質スコア: 6.8/10

良い点:
✓ RESTful APIの設計が適切
✓ エラーレスポンスの形式が統一
✓ ミドルウェアの活用が適切

改善点:
△ エラーハンドリングの一貫性（15箇所）
△ セキュリティ懸念（3件）
△ N+1クエリ問題（6箇所）

主要な問題:

1. src/backend/routes/users.ts:45
   - 問題: SQLインジェクションの可能性
   - 推奨: パラメータ化クエリの使用

2. src/backend/services/dataService.ts:78
   - 問題: N+1クエリ
   - 推奨: JOINまたはバッチ取得の使用

3. src/backend/middleware/auth.ts:23
   - 問題: 弱いトークン検証
   - 推奨: より厳格な検証ロジック

総合評価:

全体スコア: 7.2/10

優先的に対応すべき項目:

1. 【高】バックエンドのセキュリティ問題（3件）
2. 【高】N+1クエリ問題（6箇所）
3. 【中】フロントエンドのアクセシビリティ（12箇所）
4. 【中】大きなコンポーネントの分割（5個）

次のステップ:

1. セキュリティ問題から優先的に修正
2. パフォーマンス問題（N+1クエリ）の対応
3. アクセシビリティの段階的改善
4. コンポーネント設計の見直し

詳細な修正計画を立てますか？

```

## まとめ

この汎用サブエージェント実行スキルは、様々なタスクを別セッションで効率的に実行し、メインセッションのコンテキストウィンドウを節約するための強力なツールです。

### 主な利点

1. **コンテキスト節約**: メインセッションを軽量に保つ
2. **並列実行**: 複数タスクの同時実行が可能
3. **柔軟性**: あらゆる種類のタスクに対応
4. **効率性**: 詳細な実行過程はサブエージェントで処理

### 使用のコツ

- タスクを明確に定義する
- 適切なサブエージェントタイプを選択
- 期待する成果物を具体的に指定
- 制約条件を明示する

この例集を参考に、様々なシナリオで汎用サブエージェントを活用してください。
