---
name: "コードレビュー"
description: "コードレビュー時の思考プロセス。レビュー、確認、評価、品質チェックに関する依頼に対応"
---

# コードレビュー: コードレビュー時の思考プロセス

## このスキルを使う場面

- 既存のコード・PR の評価が目的
- 品質チェック・改善提案が求められる
- コードの問題点を指摘する必要がある
- 設計の妥当性を確認する
- ベストプラクティスへの準拠を確認する
- チームメンバーへのフィードバック

## 思考プロセス

### フェーズ1: レビュー準備と全体把握

**ステップ1: 背景・文脈の理解**

レビュー対象の背景を理解する：

**変更の目的:**

- [ ] 何を実現しようとしているか
- [ ] なぜこの変更が必要か
- [ ] どんな問題を解決するか
- [ ] 関連する Issue・チケット

**変更の範囲:**

- [ ] どのファイルが変更されたか
- [ ] 何行変更されたか
- [ ] 影響を受ける機能・モジュール
- [ ] 依存関係の変更

**作成者の意図:**

- [ ] PR の説明を読む
- [ ] コミットメッセージを確認
- [ ] テストケースを見る
- [ ] なぜそのアプローチを選んだか

**ステップ2: 全体像の把握**

詳細を見る前に全体を理解：

**1. ざっと読む（5-10 分）**

- すべてのファイルに目を通す
- 大きな構造・パターンを把握
- 気になる箇所をメモ

**2. アーキテクチャへの影響**

- 既存の設計と整合しているか
- 新しいパターン・規約を導入しているか
- 依存関係が適切か

**3. テストの確認**

- テストが追加されているか
- テストカバレッジは十分か
- テストケースは適切か

**移行条件:**

- [ ] 変更の目的を理解した
- [ ] 全体像を把握した
- [ ] レビューの観点を決めた

### フェーズ2: レビューの観点と優先順位

**レビューの観点（優先順位順）:**

**1. 正確性（最優先）**

コードが正しく動作するか：

- [ ] バグがないか
- [ ] エッジケースを処理しているか
- [ ] エラーハンドリングが適切か
- [ ] データの整合性が保たれるか

**チェック項目:**

- Null/undefined チェック
- インデックス範囲外アクセス
- 型の不一致
- 境界値の処理
- 非同期処理の考慮

**2. セキュリティ**

セキュリティ上の問題がないか：

- [ ] SQL インジェクションの可能性
- [ ] XSS の可能性
- [ ] 認証・認可の抜け
- [ ] 機密情報の露出
- [ ] 入力検証の不足

**3. パフォーマンス**

著しい性能問題がないか：

- [ ] N+1 クエリ
- [ ] 不要なループ・計算
- [ ] メモリリーク
- [ ] 大量データでの動作

**4. 可読性**

他の人が理解できるか：

- [ ] 分かりやすい命名
- [ ] 適切なコメント
- [ ] 論理的な構造
- [ ] 複雑すぎないか

**5. 保守性**

将来変更しやすいか：

- [ ] 適切な抽象化
- [ ] 単一責任の原則
- [ ] DRY（重複排除）
- [ ] テスタビリティ

**6. 一貫性**

既存コードとの整合性：

- [ ] コーディング規約への準拠
- [ ] 既存パターンとの一貫性
- [ ] ネーミング規則
- [ ] ファイル構造

**7. 文書化**

適切なドキュメントがあるか：

- [ ] API ドキュメント
- [ ] コメント
- [ ] README の更新
- [ ] 変更履歴

**移行条件:**

- [ ] レビューの観点を理解した
- [ ] 優先順位を認識した
- [ ] チェックリストを準備した

### フェーズ3: 詳細レビューの実施

**ステップ1: 正確性のレビュー**

**1. ロジックの検証**

各関数・メソッドについて：

- 入力が正しく処理されるか
- アルゴリズムが正しいか
- 条件分岐が適切か
- ループが正しく終了するか

**2. エラーハンドリング**

```python
# 悪い例
def get_user(user_id):
    return database.query(user_id)  # エラー処理なし

# 良い例
def get_user(user_id):
    try:
        return database.query(user_id)
    except DatabaseError as e:
        logger.error(f"Failed to get user {user_id}: {e}")
        raise UserNotFoundError(f"User {user_id} not found")
```

**3. エッジケースの確認**

- 空データ（空配列、空文字列）
- Null/undefined
- 境界値（0、最大値、最小値）
- 不正な入力

**4. 非同期処理**

- レースコンディション
- デッドロック
- タイムアウト処理
- エラーハンドリング

**ステップ2: セキュリティのレビュー**

**1. 入力検証**

```python
# 悪い例
def delete_user(user_id):
    query = f"DELETE FROM users WHERE id = {user_id}"  # SQL インジェクション
    db.execute(query)

# 良い例
def delete_user(user_id):
    if not isinstance(user_id, int) or user_id <= 0:
        raise ValueError("Invalid user ID")
    query = "DELETE FROM users WHERE id = ?"
    db.execute(query, (user_id,))
```

**2. 認証・認可**

- すべてのエンドポイントで認証されているか
- 権限チェックが適切か
- セッション管理が安全か

**3. データ保護**

- パスワードがハッシュ化されているか
- 機密情報がログに出力されていないか
- 暗号化が適切か

**ステップ3: パフォーマンスのレビュー**

**1. データベースクエリ**

```python
# 悪い例（N+1 問題）
for user in users:
    posts = get_posts(user.id)  # N 回クエリ

# 良い例
posts_by_user = get_all_posts(user_ids)  # 1 回のクエリ
```

**2. アルゴリズムの効率**

- 時間計算量（O(n) vs O(n²)）
- 空間計算量
- 不要な計算の削除

**3. キャッシングの検討**

- 頻繁にアクセスされるデータ
- 計算コストの高い処理
- キャッシュの無効化戦略

**ステップ4: 可読性のレビュー**

**1. 命名**

```python
# 悪い例
def f(x, y):
    return x * y + 100

# 良い例
def calculate_total_price(unit_price, quantity):
    base_price = unit_price * quantity
    service_fee = 100
    return base_price + service_fee
```

**2. 関数の長さ**

- 50 行以上 → 分割を検討
- 単一責任を守る
- ネストの深さは 3 段階まで

**3. コメント**

```python
# 悪い例
x = x + 1  # x に 1 を加える（何をしているか）

# 良い例
x = x + 1  # オフセットを調整（配列は 0 始まりだが、UI は 1 始まり）（なぜ）
```

**ステップ5: 保守性のレビュー**

**1. 重複の排除**

同じコードが複数箇所 → 関数に抽出

**2. 適切な抽象化**

- インターフェースが明確
- 実装の詳細が隠蔽されている
- 拡張しやすい

**3. テスタビリティ**

- モック・スタブが可能
- 依存性注入
- 純粋関数の活用

**ステップ6: 一貫性のレビュー**

**1. コーディング規約**

- インデント（スペース vs タブ）
- 命名規則（camelCase vs snake_case）
- ファイル構成
- import の順序

**2. 既存パターンとの整合性**

- エラーハンドリングの方法
- ロギングの方法
- API の設計パターン

**移行条件:**

- [ ] すべての観点でレビューした
- [ ] 問題点を特定した
- [ ] 改善提案を用意した

### フェーズ4: フィードバックの作成

**ステップ1: フィードバックの優先順位付け**

見つけた問題を優先順位付け：

**Critical（必須修正）:**

- バグ・セキュリティ問題
- データ損失の可能性
- 重大なパフォーマンス問題

**Major（強く推奨）:**

- 設計上の問題
- 保守性の大きな問題
- テストの不足

**Minor（推奨）:**

- 可読性の改善
- 小さなリファクタリング
- コメントの追加

**Nit（些細な指摘）:**

- タイポ
- スタイルの統一
- 細かい命名

**ステップ2: 建設的なフィードバックの作成**

**1. 具体的に指摘**

```
# 悪い例
「このコードは分かりにくいです」

# 良い例
「この関数は 3 つの異なる責任を持っています（ユーザー取得、検証、保存）。
単一責任の原則に従って、3 つの関数に分割することを推奨します。」
```

**2. 理由を説明**

```
# 悪い例
「変数名を変更してください」

# 良い例
「変数名 `data` は汎用的すぎて意図が分かりません。
`user_profile_data` のように、何のデータかが分かる名前にすると、
コードの可読性が向上します。」
```

**3. 代替案を提示**

```
# 悪い例
「このアプローチは良くないです」

# 良い例
「現在の実装では N+1 クエリが発生します。
代わりに JOIN を使うか、バッチクエリを使うことで、
パフォーマンスを大幅に改善できます。

例:
SELECT posts.* FROM posts
JOIN users ON posts.user_id = users.id
WHERE users.id IN (?, ?, ...)
```

**4. ポジティブな指摘も含める**

- 良い設計・実装を褒める
- 改善された点を認める
- 学んだことを共有

**ステップ3: フィードバックの伝え方**

**1. 質問形式**

```
「この実装だと○○の場合に問題が起きませんか？」
「△△のアプローチも検討されましたか？」
```

**2. 提案形式**

```
「○○を△△に変更すると、より明確になると思います」
「□□を追加すると、エッジケースもカバーできます」
```

**3. 共感を示す**

```
「この部分は確かに複雑ですね。私も同じような実装で苦労しました」
「時間の制約がある中でよく実装されていると思います」
```

**移行条件:**

- [ ] フィードバックを作成した
- [ ] 優先順位を明確にした
- [ ] 建設的な表現にした

## 判断のポイント

### どこまで指摘すべきか

**必ず指摘:**

- バグ・セキュリティ問題
- データ損失の可能性
- 重大なパフォーマンス問題
- 明らかな設計ミス

**状況に応じて指摘:**

- スタイルの問題（規約がある場合）
- 小さなリファクタリング
- 可読性の改善

**指摘しない方が良い:**

- 個人の好み
- 些細すぎる問題
- スコープ外の変更

### レビューに時間をかけすぎない

**目安:**

- 小規模（< 100 行）: 15-30 分
- 中規模（100-500 行）: 30-60 分
- 大規模（> 500 行）: 複数回に分けてレビュー

**時間がかかりすぎる場合:**

- 変更が大きすぎる → 分割を依頼
- 複雑すぎる → ペアレビュー・会議を提案
- 理解に時間がかかる → 説明を依頼

## よくある落とし穴

1. **否定的すぎる**
   - ❌ 問題点だけ指摘
   - ✅ ポジティブな点も認める

2. **曖昧な指摘**
   - ❌ 「良くない」「分かりにくい」
   - ✅ 具体的に何が問題か説明

3. **代替案なし**
   - ❌ 批判だけ
   - ✅ 改善案を提示

4. **些細なことに固執**
   - ❌ スペースの数にこだわる
   - ✅ 本質的な問題に集中

5. **全部を直させようとする**
   - ❌ 完璧を求めすぎる
   - ✅ 優先順位をつける

6. **文脈を無視**
   - ❌ 理想論だけ
   - ✅ 制約・背景を考慮

7. **個人攻撃**
   - ❌ 「あなたは○○が分かっていない」
   - ✅ 「このコードは○○です」

## 検証ポイント

### レビュー前

- [ ] 変更の目的を理解した
- [ ] 全体像を把握した
- [ ] レビューの観点を決めた

### レビュー中

- [ ] 正確性を確認した
- [ ] セキュリティを確認した
- [ ] パフォーマンスを確認した
- [ ] 可読性を確認した
- [ ] 保守性を確認した

### レビュー後

- [ ] フィードバックが具体的
- [ ] 優先順位が明確
- [ ] 建設的な表現
- [ ] 代替案を提示した

## 他スキルとの連携

### code-review → debugging

レビューでバグ発見：

1. このスキルでバグを特定
2. debugging スキルで根本原因を分析
3. 修正方法を提案

### code-review → refactoring

コード品質の改善提案：

1. このスキルで改善点を指摘
2. refactoring スキルで具体的な改善方法
3. 段階的な改善計画を提案

### code-review → system-design

設計上の問題発見：

1. このスキルで設計の問題を発見
2. system-design スキルで代替設計を提案
3. アーキテクチャレベルの改善

### code-review + documentation

ドキュメントのレビュー：

1. このスキルでコードレビュー
2. documentation スキルでドキュメントの適切性を確認
3. ドキュメントの改善提案

## レビューのベストプラクティス

### 早期レビュー

- WIP（Work In Progress）の段階でレビュー
- 方向性の確認
- 大きな手戻りを防ぐ

### 小さく頻繁に

- 小さな PR を頻繁に
- レビューしやすい
- 早くマージできる

### 自動化の活用

- Linter でスタイルチェック
- CI で自動テスト
- 人間は本質的な問題に集中

### 学習の機会

- なぜそうしたか理解する
- 新しい技術・パターンを学ぶ
- チーム全体のスキル向上

### 建設的な議論

- レビューは対話
- 双方向のコミュニケーション
- より良い解決策を一緒に見つける
