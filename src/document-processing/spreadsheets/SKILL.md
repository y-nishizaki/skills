---
name: スプレッドシート
description: "数式、書式設定、データ分析、可視化をサポートする包括的なスプレッドシート作成、編集、分析機能。Claudeが以下の作業でスプレッドシート（.xlsx、.xlsm、.csv、.tsvなど）を扱う必要がある場合：(1) 数式と書式設定を含む新規スプレッドシート作成、(2) データの読み取りまたは分析、(3) 数式を保持した既存スプレッドシートの修正、(4) スプレッドシート内でのデータ分析と可視化、または (5) 数式の再計算"
license: Proprietary. LICENSE.txtに完全な条件が記載されています
---

# 成果物の要件

## すべてのExcelファイル

### 数式エラーゼロ
- すべてのExcelモデルは数式エラーゼロ（#REF!、#DIV/0!、#VALUE!、#N/A、#NAME?）で納品する必要があります

### 既存テンプレートの保持（テンプレート更新時）
- ファイルを修正する際は、既存の書式、スタイル、規則を調査し、完全に一致させる
- 確立されたパターンを持つファイルに標準化された書式を適用しない
- 既存テンプレートの規則は常にこれらのガイドラインよりも優先されます

## 財務モデル

### カラーコーディング標準
ユーザーまたは既存テンプレートで別途指定がない限り

#### 業界標準のカラー規則
- **青色テキスト (RGB: 0,0,255)**: ハードコーディングされた入力値、およびユーザーがシナリオに応じて変更する数値
- **黒色テキスト (RGB: 0,0,0)**: すべての数式と計算
- **緑色テキスト (RGB: 0,128,0)**: 同じワークブック内の他のワークシートから取得するリンク
- **赤色テキスト (RGB: 255,0,0)**: 他のファイルへの外部リンク
- **黄色背景 (RGB: 255,255,0)**: 注意が必要な主要な仮定、または更新が必要なセル

### 数値書式設定標準

#### 必須書式ルール
- **年**: テキスト文字列として書式設定（例：「2024」、「2,024」ではない）
- **通貨**: $#,##0書式を使用。ヘッダーで常に単位を指定（「売上高 ($mm)」）
- **ゼロ**: すべてのゼロを「-」で表示する数値書式を使用（パーセンテージを含む）（例：「$#,##0;($#,##0);-」）
- **パーセンテージ**: デフォルトで0.0%書式（小数点1桁）
- **倍数**: 評価倍率にはEV/EBITDA、P/Eなど0.0x書式を使用
- **負の数**: マイナス記号-123ではなく括弧 (123) を使用

### 数式構築ルール

#### 仮定の配置
- すべての仮定（成長率、マージン、倍率など）を別の仮定セルに配置
- 数式内でハードコーディングされた値ではなくセル参照を使用
- 例: =B5*1.05ではなく=B5*(1+$B$6)を使用

#### 数式エラー防止
- すべてのセル参照が正しいことを確認
- 範囲のオフバイワンエラーをチェック
- すべての予測期間で一貫した数式を確保
- エッジケース（ゼロ値、負の数）でテスト
- 意図しない循環参照がないことを確認

#### ハードコーディング値の文書化要件
- セル内またはその横（テーブルの終わりの場合）にコメント。書式：「出典: [システム/文書]、[日付]、[具体的な参照]、[該当する場合URL]」
- 例：
  - 「出典: 会社10-K、FY2024、45ページ、売上高注記、[SEC EDGAR URL]」
  - 「出典: 会社10-Q、Q2 2025、別紙99.1、[SEC EDGAR URL]」
  - 「出典: Bloombergターミナル、2025年8月15日、AAPL US Equity」
  - 「出典: FactSet、2025年8月20日、コンセンサス予測画面」

# XLSXの作成、編集、分析

## 概要

ユーザーは、.xlsxファイルの作成、編集、または内容の分析を依頼する場合があります。異なるタスクに対して異なるツールとワークフローが利用可能です。

## 重要な要件

**数式再計算にはLibreOfficeが必要**: `recalc.py`スクリプトを使用して数式の値を再計算するには、LibreOfficeがインストールされていることを前提とします。スクリプトは初回実行時にLibreOfficeを自動的に設定します

## データの読み取りと分析

### pandasを使用したデータ分析
データ分析、可視化、基本操作には、強力なデータ操作機能を提供する**pandas**を使用します：

```python
import pandas as pd

# Excel読み取り
df = pd.read_excel('file.xlsx')  # デフォルト: 最初のシート
all_sheets = pd.read_excel('file.xlsx', sheet_name=None)  # すべてのシートを辞書として

# 分析
df.head()      # データのプレビュー
df.info()      # 列情報
df.describe()  # 統計情報

# Excel書き込み
df.to_excel('output.xlsx', index=False)
```

## Excelファイルのワークフロー

## 重要: 数式を使用し、ハードコーディングされた値を使用しない

**Pythonで値を計算してハードコーディングするのではなく、常にExcelの数式を使用してください。** これにより、スプレッドシートが動的で更新可能な状態に保たれます。

### ❌ 誤り - 計算値のハードコーディング
```python
# 悪い例: Pythonで計算して結果をハードコーディング
total = df['Sales'].sum()
sheet['B10'] = total  # 5000をハードコーディング

# 悪い例: Pythonで成長率を計算
growth = (df.iloc[-1]['Revenue'] - df.iloc[0]['Revenue']) / df.iloc[0]['Revenue']
sheet['C5'] = growth  # 0.15をハードコーディング

# 悪い例: Pythonで平均を計算
avg = sum(values) / len(values)
sheet['D20'] = avg  # 42.5をハードコーディング
```

### ✅ 正しい - Excel数式の使用
```python
# 良い例: Excelに合計を計算させる
sheet['B10'] = '=SUM(B2:B9)'

# 良い例: Excel数式として成長率
sheet['C5'] = '=(C4-C2)/C2'

# 良い例: Excel関数を使用した平均
sheet['D20'] = '=AVERAGE(D2:D19)'
```

これは、合計、パーセンテージ、比率、差分など、すべての計算に適用されます。ソースデータが変更されたときにスプレッドシートが再計算できる必要があります。

## 一般的なワークフロー
1. **ツールを選択**: データにはpandas、数式/書式設定にはopenpyxl
2. **作成/読み込み**: 新しいワークブックを作成するか、既存ファイルを読み込む
3. **修正**: データ、数式、書式設定を追加/編集
4. **保存**: ファイルに書き込み
5. **数式の再計算（数式を使用する場合は必須）**: recalc.pyスクリプトを使用
   ```bash
   python recalc.py output.xlsx
   ```
6. **エラーの検証と修正**:
   - スクリプトはエラーの詳細を含むJSONを返します
   - `status`が`errors_found`の場合、`error_summary`で特定のエラータイプと場所を確認
   - 特定されたエラーを修正し、再度再計算
   - 修正すべき一般的なエラー：
     - `#REF!`: 無効なセル参照
     - `#DIV/0!`: ゼロ除算
     - `#VALUE!`: 数式内の誤ったデータ型
     - `#NAME?`: 認識されない数式名

### 新しいExcelファイルの作成

```python
# 数式と書式設定にはopenpyxlを使用
from openpyxl import Workbook
from openpyxl.styles import Font, PatternFill, Alignment

wb = Workbook()
sheet = wb.active

# データを追加
sheet['A1'] = 'Hello'
sheet['B1'] = 'World'
sheet.append(['Row', 'of', 'data'])

# 数式を追加
sheet['B2'] = '=SUM(A1:A10)'

# 書式設定
sheet['A1'].font = Font(bold=True, color='FF0000')
sheet['A1'].fill = PatternFill('solid', start_color='FFFF00')
sheet['A1'].alignment = Alignment(horizontal='center')

# 列幅
sheet.column_dimensions['A'].width = 20

wb.save('output.xlsx')
```

### 既存Excelファイルの編集

```python
# 数式と書式設定を保持するためにopenpyxlを使用
from openpyxl import load_workbook

# 既存ファイルを読み込み
wb = load_workbook('existing.xlsx')
sheet = wb.active  # または特定シートの場合はwb['SheetName']

# 複数シートの操作
for sheet_name in wb.sheetnames:
    sheet = wb[sheet_name]
    print(f"Sheet: {sheet_name}")

# セルを修正
sheet['A1'] = 'New Value'
sheet.insert_rows(2)  # 位置2に行を挿入
sheet.delete_cols(3)  # 列3を削除

# 新しいシートを追加
new_sheet = wb.create_sheet('NewSheet')
new_sheet['A1'] = 'Data'

wb.save('modified.xlsx')
```

## 数式の再計算

openpyxlで作成または修正されたExcelファイルには、数式が文字列として含まれていますが、計算値は含まれていません。提供されている`recalc.py`スクリプトを使用して数式を再計算します：

```bash
python recalc.py <excel_file> [timeout_seconds]
```

例：
```bash
python recalc.py output.xlsx 30
```

スクリプトの機能：
- 初回実行時にLibreOfficeマクロを自動的に設定
- すべてのシートのすべての数式を再計算
- すべてのセルでExcelエラー（#REF!、#DIV/0!など）をスキャン
- エラーの詳細な場所とカウントを含むJSONを返す
- LinuxとmacOSの両方で動作

## 数式検証チェックリスト

数式が正しく機能することを確認するための簡単なチェック：

### 必須検証
- [ ] **2〜3個のサンプル参照をテスト**: モデル全体を構築する前に正しい値を引いていることを確認
- [ ] **列マッピング**: Excel列が一致することを確認（例：列64 = BL、BKではない）
- [ ] **行オフセット**: Excel行は1インデックスであることを覚えておく（DataFrame行5 = Excel行6）

### よくある落とし穴
- [ ] **NaN処理**: `pd.notna()`でnull値をチェック
- [ ] **右端の列**: FYデータは多くの場合列50以上
- [ ] **複数の一致**: 最初だけでなくすべての出現を検索
- [ ] **ゼロ除算**: 数式で`/`を使用する前に分母をチェック（#DIV/0!）
- [ ] **誤った参照**: すべてのセル参照が意図したセルを指していることを確認（#REF!）
- [ ] **シート間参照**: シートをリンクするための正しい書式を使用（Sheet1!A1）

### 数式テスト戦略
- [ ] **小規模から開始**: 広く適用する前に2〜3個のセルで数式をテスト
- [ ] **依存関係を確認**: 数式で参照されているすべてのセルが存在することを確認
- [ ] **エッジケースをテスト**: ゼロ、負の値、非常に大きな値を含める

### recalc.py出力の解釈
スクリプトはエラーの詳細を含むJSONを返します：
```json
{
  "status": "success",           // または "errors_found"
  "total_errors": 0,              // 総エラー数
  "total_formulas": 42,           // ファイル内の数式数
  "error_summary": {              // エラーが見つかった場合のみ存在
    "#REF!": {
      "count": 2,
      "locations": ["Sheet1!B5", "Sheet1!C10"]
    }
  }
}
```

## ベストプラクティス

### ライブラリの選択
- **pandas**: データ分析、一括操作、シンプルなデータエクスポートに最適
- **openpyxl**: 複雑な書式設定、数式、Excel固有の機能に最適

### openpyxlの操作
- セルインデックスは1ベース（row=1, column=1はセルA1を指す）
- 計算値を読み取るには`data_only=True`を使用：`load_workbook('file.xlsx', data_only=True)`
- **警告**: `data_only=True`で開いて保存すると、数式は値に置き換えられ、永久に失われます
- 大きなファイルの場合：読み取りには`read_only=True`、書き込みには`write_only=True`を使用
- 数式は保持されますが評価されません - 値を更新するにはrecalc.pyを使用

### pandasの操作
- 推論の問題を避けるためにデータ型を指定：`pd.read_excel('file.xlsx', dtype={'id': str})`
- 大きなファイルの場合、特定の列を読み取る：`pd.read_excel('file.xlsx', usecols=['A', 'C', 'E'])`
- 日付を適切に処理：`pd.read_excel('file.xlsx', parse_dates=['date_column'])`

## コードスタイルガイドライン
**重要**: Excel操作用のPythonコードを生成する場合：
- 不要なコメントを含まない最小限の簡潔なPythonコードを記述
- 冗長な変数名や不要な操作を避ける
- 不要なprint文を避ける

**Excelファイル自体の場合**：
- 複雑な数式や重要な仮定を含むセルにコメントを追加
- ハードコーディングされた値のデータソースを文書化
- 主要な計算とモデルセクションのメモを含める
