---
name: "前提検証"
description: "主張や判断の土台となる前提・仮定を洗い出し、その妥当性を系統的に検証するスキル。「そもそもそれは本当か？」を問い、情報源の信頼性確認や反例探索を通じて、より確実な意思決定の基盤を構築する際に使用"
---

# 前提検証: 判断の土台を問い直す思考プロセス

## このスキルを使う場面

- 重要な意思決定の前に土台を固めたい
- 「常識」や「当然」とされることの妥当性を確認したい
- 情報や主張の信頼性を評価したい
- 一般化された意見の根拠を確かめたい
- プロジェクトや実装の前提条件を明確にしたい
- 「そもそも論」で問題の本質に迫りたい

## 思考プロセス

### フェーズ1: 前提の洗い出し

**ステップ1: PAC分析（Premise-Assumption-Conclusion）**

主張や判断をPAC構造に分解する：

1. **P (Premise / 前提)**
   - [ ] 明示的に述べられている事実や根拠は何か
   - [ ] 検証可能なデータや情報は何か
   - [ ] 前提の出所は明確か

2. **A (Assumption / 仮定)**
   - [ ] 明示されていないが暗黙に仮定されていることは何か
   - [ ] 「当然」と思われている条件は何か
   - [ ] 証拠がなく推測されていることは何か

3. **C (Conclusion / 結論)**
   - [ ] 導き出される結論は何か
   - [ ] PとAから論理的に導かれているか
   - [ ] 結論は前提に依存しているか

PAC分析の例：

```
主張: 「このライブラリを使えば開発が早くなる」

P (前提):
- ライブラリXは多機能である
- 他のプロジェクトで採用されている

A (仮定):
- チームメンバーがこのライブラリを学習できる
- プロジェクトの要件に適合する
- パフォーマンスは十分である
- 長期的に保守される

C (結論):
- このライブラリを採用すべき

→ 仮定の検証が必要
```

**ステップ2: 明示的前提と暗黙的前提の分類**

前提を可視化する：

明示的前提（Explicit Assumptions）：

```
✓ 文書化されている前提
✓ 明確に述べられている条件
✓ チーム全員が認識している前提
```

暗黙的前提（Implicit Assumptions）チェックリスト：

- [ ] データの完全性（NULL値なし、異常値なし）
- [ ] 環境の一貫性（開発環境=本番環境）
- [ ] タイミング（順序保証、同期/非同期）
- [ ] 外部依存の可用性（API、DB、サービス）
- [ ] ユーザー行動の想定
- [ ] リソースの制約（メモリ、CPU、ネットワーク）
- [ ] 時間の制約（処理時間、期限）
- [ ] 組織の前提（承認プロセス、権限）

暗黙的前提の発見質問：

```
- 「もし〜がなかったら、この結論は成り立つか？」
- 「何を『当然』と思っているか？」
- 「新しいメンバーはこれを知っているか？」
- 「6ヶ月後もこの前提は有効か？」
```

**ステップ3: 前提の階層化**

前提間の依存関係を整理する：

```
レベル1: 基礎的前提
↓ （これが崩れると上位すべてが崩れる）
レベル2: 派生的前提
↓
レベル3: 具体的前提
```

例：

```
レベル1: ユーザーはインターネットに接続できる
  ↓
レベル2: APIにアクセスできる
  ↓
レベル3: リアルタイムで通知を受け取れる
```

**移行条件:**

- [ ] 主張をPAC構造に分解した
- [ ] 暗黙的前提を洗い出した
- [ ] 前提の階層と依存関係を整理した

### フェーズ2: 前提の妥当性検証

**ステップ1: 「そもそもそれは本当か？」の問い**

各前提に対して根本的な問いを投げかける：

5つの検証観点：

1. **事実性（Factuality）**

   ```
   - これは事実か、意見か？
   - 検証可能か？
   - 測定可能か？
   ```

   事実と意見の区別：

   ```
   事実: 「昨日のAPIレスポンス時間は500msだった」
   意見: 「このAPIは遅い」
   ```

2. **時間的妥当性（Temporal Validity）**

   ```
   - いつ時点の情報か？
   - 現在も有効か？
   - どのくらいの期間有効か？
   ```

3. **範囲の妥当性（Scope Validity）**

   ```
   - どの範囲で成り立つか？
   - すべての場合に当てはまるか？
   - 例外はないか？
   ```

4. **条件依存性（Conditional Dependencies）**

   ```
   - どんな条件下で成り立つか？
   - 条件が変わったらどうなるか？
   - 前提条件は満たされているか？
   ```

5. **証拠の有無（Evidence）**

   ```
   - 裏付けとなるデータはあるか？
   - 経験則か、実証されたことか？
   - 再現可能か？
   ```

**ステップ2: 情報源の信頼性検証**

前提の根拠となる情報源を評価する：

CRAADフレームワーク：

1. **C (Currency / 最新性)**

   ```
   - [ ] 情報はいつのものか？
   - [ ] 最新の状況を反映しているか？
   - [ ] 更新されているか？
   ```

2. **R (Relevance / 関連性)**

   ```
   - [ ] この状況に適用できるか？
   - [ ] 文脈が一致しているか？
   - [ ] 規模やスコープが近いか？
   ```

3. **A (Authority / 権威性)**

   ```
   - [ ] 誰が言っているか？
   - [ ] その分野の専門家か？
   - [ ] 実績や経験があるか？
   ```

4. **A (Accuracy / 正確性)**

   ```
   - [ ] 事実に基づいているか？
   - [ ] 検証可能か？
   - [ ] 他の情報源と一致しているか？
   ```

5. **D (Diversity / 多様性)**

   ```
   - [ ] 複数の情報源で確認したか？
   - [ ] 異なる視点から検証したか？
   - [ ] 偏りはないか？
   ```

情報源の信頼性スコアリング：

```
一次情報（最も信頼性が高い）:
✓ 直接観察したデータ
✓ 公式ドキュメント
✓ 実測値、ログ

二次情報:
⚠ 専門家の分析
⚠ 技術記事
⚠ ケーススタディ

三次情報（慎重に扱う）:
⚠ 又聞き
⚠ 一般的な意見
⚠ 個人的な印象
```

**ステップ3: 反例の探索**

前提が成り立たない場合を探す：

反例探索の3つのアプローチ：

1. **エッジケースの検討**

   ```
   - 最小値/最大値では？
   - ゼロの場合は？
   - 空の場合は？
   - 極端に大きい/小さい場合は？
   ```

2. **例外条件の列挙**

   ```
   - どんな時に成り立たないか？
   - 過去に失敗した事例は？
   - 他の環境ではどうか？
   ```

3. **逆説的検証**

   ```
   「もし前提が間違っていたら？」
   「反対のことが真実だとしたら？」
   ```

反例が見つかった場合：

```
反例あり → 前提を修正
   ↓
「常に」→「通常」
「すべて」→「ほとんど」
「必ず」→「おそらく」
```

**移行条件:**

- [ ] 各前提の妥当性を検証した
- [ ] 情報源の信頼性を評価した
- [ ] 反例を探索した
- [ ] 問題のある前提を特定した

### フェーズ3: 一般化の検証

**ステップ1: 一般化の根拠確認**

一般化された意見が適切かを検証する：

一般化のチェックリスト：

1. **サンプルサイズ**

   ```
   - [ ] どれくらいの事例に基づいているか？
   - [ ] サンプルは十分か？
   - [ ] 統計的に有意か？
   ```

2. **代表性**

   ```
   - [ ] サンプルは全体を代表しているか？
   - [ ] 偏りはないか？
   - [ ] 選択バイアスはないか？
   ```

3. **早まった一般化の検出**

   ```
   ❌ 「2回試して失敗したから、この方法は使えない」
   ✅ 「2回試して失敗した。他の条件でも試す必要がある」
   ```

**ステップ2: 具体例による裏付け**

一般化された主張を具体例で検証する：

具体例による検証プロセス：

1. **具体例を要求**

   ```
   主張: 「このパターンは保守性が高い」
   ↓
   質問: 「具体的にどのような場面で保守しやすいか？」
   ```

2. **複数の具体例で確認**

   ```
   具体例1: ケースA
   具体例2: ケースB
   具体例3: ケースC
   ↓
   パターンが一貫しているか確認
   ```

3. **反証例の確認**

   ```
   「保守性が高くない例はあるか？」
   「どんな場合に当てはまらないか？」
   ```

抽象-具体の往復：

```
抽象（一般化）
  ↕ 往復して検証
具体（個別事例）

例:
抽象: 「マイクロサービスはスケーラブル」
  ↓
具体: 「どのサービスがどうスケールした？」
  ↓
検証: 「小規模チームでも成立するか？」
```

**ステップ3: 条件・範囲・制約の明確化**

一般化の適用範囲を明確にする：

条件の明確化テンプレート：

```
「[条件]の場合、[範囲]において、[制約]のもとで、[主張]が成り立つ」

例:
× 「マイクロサービスは優れている」
○ 「独立してスケールする必要がある複数機能を持つシステムにおいて、
   十分なチーム規模と運用体制があれば、
   マイクロサービスアーキテクチャは保守性とスケーラビリティで優れる」
```

適用範囲の境界明示：

```
✓ 適用できる範囲
⚠ 慎重に判断すべき範囲
✗ 適用できない範囲
```

**移行条件:**

- [ ] 一般化の根拠を確認した
- [ ] 具体例で裏付けた
- [ ] 適用条件と範囲を明確にした

### フェーズ4: 前提の改善と代替案

**ステップ1: 前提のリスク評価**

各前提のリスクを評価する：

リスクマトリクス：

```
                高リスク         中リスク         低リスク
影響度 高        最優先対応       重点対応         監視
影響度 中        重点対応         通常対応         受容
影響度 低        通常対応         受容            無視可
                ↑               ↑               ↑
             確実性低         確実性中         確実性高
```

評価基準：

1. **確実性（Certainty）**

   ```
   高: 実証されている、データがある
   中: 合理的に推測できる
   低: 不確実、推測に過ぎない
   ```

2. **影響度（Impact）**

   ```
   高: 前提が崩れると致命的
   中: 前提が崩れると大きな影響
   低: 前提が崩れても影響は限定的
   ```

**ステップ2: 前提の強化**

問題のある前提を改善する：

強化の方法：

1. **証拠の追加**

   ```
   弱い前提: 「おそらく〜だろう」
   ↓
   強化: データ収集、実験、プロトタイプ
   ↓
   強い前提: 「測定の結果、〜である」
   ```

2. **条件の明確化**

   ```
   曖昧: 「高速である」
   ↓
   明確: 「95パーセンタイルで200ms以内」
   ```

3. **検証可能性の追加**

   ```
   検証不可: 「将来も安定している」
   ↓
   検証可: 「過去2年間、月次更新が継続している」
   ```

**ステップ3: 代替前提の検討**

より確実な前提を探す：

代替前提の探索：

```
現在の前提: APIは常に利用可能
↓
リスク: 外部依存、障害時に機能停止
↓
代替前提:
1. APIが一時的に利用不可でも動作する（キャッシュ）
2. 複数APIでフォールバック
3. オフラインモードを提供
```

前提の緩和：

```
強い前提: 「すべてのユーザーが最新ブラウザ」
↓ 緩和
弱い前提: 「80%のユーザーが最新ブラウザ」
↓ 対応追加
「残り20%には代替UI提供」
```

**移行条件:**

- [ ] 前提のリスクを評価した
- [ ] 高リスク前提を強化した
- [ ] 必要に応じて代替前提を検討した

## 判断のポイント

### どこまで検証すべきか

検証の深さの判断基準：

```
浅い検証（5-10分）:
- 日常的な判断
- 小規模で可逆的な決定
- 影響範囲が限定的

中程度の検証（30分-1時間）:
- プロジェクトの方針決定
- 技術選択
- アーキテクチャ設計

深い検証（数時間-数日）:
- 重要な戦略的決定
- 大規模投資
- 不可逆的な選択
- セキュリティ・安全性が関わる決定
```

### 前提検証の優先順位

検証すべき前提の優先順位：

```
最優先:
1. 基礎的前提（他の前提の土台）
2. 不確実性が高い前提
3. 影響度が大きい前提

次優先:
4. 暗黙的前提
5. 時間的制約がある前提

低優先:
6. 既に検証済みの前提
7. 影響が限定的な前提
```

## よくある落とし穴

1. **過度な検証**
   - ❌ すべての前提を完璧に検証しようとする
   - ✅ リスクと影響度に応じて検証レベルを調整

2. **検証の形骸化**
   - ❌ チェックリストを埋めるだけ
   - ✅ 本質的な問いを投げかける

3. **既存前提への固執**
   - ❌ 従来の前提を疑わない
   - ✅ 定期的に前提を見直す

4. **検証の先延ばし**
   - ❌ 「後で確認すればいい」
   - ✅ 早い段階で前提を検証

5. **一次情報の軽視**
   - ❌ 又聞きや一般論に依存
   - ✅ 可能な限り一次情報を確認

## 検証ポイント

### 前提の洗い出し

- [ ] PAC分析を実施した
- [ ] 暗黙的前提を発見した
- [ ] 前提の階層を整理した

### 妥当性検証

- [ ] 「そもそもそれは本当か？」を問うた
- [ ] 情報源の信頼性を評価した
- [ ] 反例を探索した

### 一般化の検証

- [ ] サンプルサイズと代表性を確認した
- [ ] 具体例で裏付けた
- [ ] 適用範囲を明確にした

### 改善

- [ ] 前提のリスクを評価した
- [ ] 高リスク前提を強化した
- [ ] 必要に応じて代替前提を検討した

## 他スキルとの連携

### assumption-verification → critical-thinking

前提検証から批判的思考へ：

1. このスキルで前提を洗い出し検証
2. critical-thinking で論理構造全体を検証
3. より堅牢な判断へ

### assumption-verification → system-design

設計の土台を固める：

1. このスキルで設計前提を検証
2. system-design で設計を具体化
3. 前提に基づいた確実な設計

### debugging + assumption-verification

バグ調査の前提確認：

1. debugging でバグを調査
2. このスキルで「このバグは〜が原因」という前提を検証
3. 真の原因を発見

## 実践例

### 例1: 技術選択の前提検証

**状況:** 「React を使うべき」という提案

**前提検証の適用:**

PAC分析：

```
P (前提):
- React は人気がある
- 豊富なエコシステム

A (仮定):
- チームが React を習得できる
- プロジェクト規模に適している
- 長期的に保守される

C (結論):
- React を採用すべき
```

仮定の検証：

```
「チームが習得できる」の検証:
- チームの現在のスキルセット確認 → JavaScript経験者2名のみ
- 学習コスト見積もり → 2-3ヶ月必要
→ 前提が弱い

「プロジェクト規模に適している」の検証:
- プロジェクト規模 → 小規模な管理画面
- React の利点 → 大規模アプリでの再利用性
→ オーバースペックの可能性

代替案検討:
- より軽量なフレームワーク
- バニラJSで十分かも
```

### 例2: パフォーマンス改善の前提検証

**状況:** 「データベースが遅いから最適化すべき」

**前提検証の適用:**

「そもそもそれは本当か？」

```
前提: データベースが遅い
↓
検証: 実測したか？
→ 実測していない、推測だった
↓
測定実施:
- DB クエリ: 平均50ms
- ネットワーク: 平均300ms
- クライアント描画: 平均2000ms
↓
発見: 本当のボトルネックはクライアント側
```

### 例3: 仕様の前提検証

**状況:** 「ユーザーIDは数値」という仕様

**前提検証の適用:**

反例の探索：

```
現在: ユーザーIDは数値（自動インクリメント）
↓
反例探索:
- ソーシャルログインの導入予定は？
  → 6ヶ月後に予定あり
- 外部システム連携は？
  → UUID を使うシステムと連携予定
- テストユーザーIDは？
  → 「test-user-1」のような文字列が便利
↓
前提の修正:
× 「ユーザーIDは数値」
○ 「ユーザーIDは文字列、現在は数値のみ運用」
↓
実装の改善:
型を string に変更、将来の拡張に備える
```

## 参考資料

より詳しい前提検証のテクニックやチェックリストについては、
`references/assumption-verification-checklist.md` を参照してください。
