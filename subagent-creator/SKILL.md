---
name: subagent-creator
description: >
  Taskツールを使用して汎用的なサブエージェントを作成し、複雑なタスクを別セッションで実行します。
  サブエージェント作成、タスク委任、並列実行、バックグラウンド処理、効率的なタスク分割を依頼された時に使用します。
  キーワード - サブエージェント作成、Task実行、並列処理、タスク委任、マルチエージェント。
version: 1.0.0
---

# サブエージェント作成スキル

## 目的

Taskツールを使用して、様々な用途のサブエージェントを効率的に作成・実行します。サブエージェントは別セッションで自律的に動作し、複雑なタスク、長時間タスク、並列処理に最適です。

## このスキルを使用するタイミング

以下の場合にこのスキルを使用します：

- ユーザーがサブエージェントの作成・実行を依頼
- 複雑なタスクを分割して並列実行したい
- コードベース探索やリサーチを別セッションで実行
- 長時間タスクをバックグラウンドで処理
- 複数の独立したタスクを同時実行

## サブエージェントの基本原則

### アーキテクチャ

サブエージェントは以下の原則に従って設計されています：

1. **ステートレス**: 同じ入力で同じ出力、状態や会話履歴なし
2. **完全隔離**: 独自のコンテキストウィンドウで動作
3. **自律的**: 追加の指示なしで完全に自己完結
4. **2層システム**:
   - メインエージェント: 全体の調整、高レベル計画、コンテキスト維持
   - サブエージェント: 専門タスク実行、詳細な技術作業

### コンテキスト管理

- サブエージェントは数万トークンを使用可能
- 1,000-2,000トークンの要約をメインエージェントに返す
- 結果はユーザーに直接表示されない（メインが要約）
- メインエージェントは定期的に`/clear`でコンテキストをリセット推奨

### パフォーマンス

- **30秒ルール**: 1タスクは30秒以内に完了すべき
- 30秒超える場合は複数のサブタスクに分解
- **並列実行**: 最大10タスク同時実行可能
- 並列実行で5分タスクを30秒に短縮可能

## サブエージェント作成プロセス

### ステップ1: タスク要件の明確化

サブエージェントを作成する前に、以下を明確にします：

1. **タスクの目的**:
   - 何を達成する必要がありますか？
   - 期待される成果物は何ですか？
   - どのような情報を返すべきですか？

2. **タスクの種類**:
   - リサーチタスク（情報収集、コードベース探索）
   - 実装タスク（コード作成、ファイル編集）
   - 分析タスク（コードレビュー、パフォーマンス分析）
   - 複合タスク（複数の操作を含む）

3. **実行環境**:
   - 同期実行（結果を待つ）
   - 非同期実行（バックグラウンドで実行）
   - 並列実行（複数のサブエージェント）

**ユーザーに確認する情報**:

- タスクの具体的な内容が不明確な場合
- 複数の解釈が可能な場合
- 期待される出力形式が不明な場合
- スコープが広すぎる場合

### ステップ2: 適切なサブエージェントタイプの選択

Claude Codeで利用可能なサブエージェントタイプから最適なものを選択します：

**1. general-purpose**:

- **用途**: 複雑な質問のリサーチ、コード検索、マルチステップタスク
- **利用可能なツール**: すべてのツール（Read, Write, Edit, Bash, Grep, Glob, WebSearch, WebFetch等）
- **適したタスク**:
  - 包括的なリサーチ
  - コードベースの広範な変更
  - 複雑な実装タスク
  - WebSearchやWebFetchが必要なタスク

**2. Explore**:

- **用途**: コードベースの探索に特化した高速エージェント
- **利用可能なツール**: Glob, Grep, Read, Bash
- **適したタスク**:
  - ファイルパターンの検索（例: "src/components/**/*.tsx"）
  - キーワードによるコード検索（例: "APIエンドポイント"）
  - コードベースに関する質問（例: "APIエンドポイントの仕組み"）
- **徹底度レベル**:
  - "quick": 基本的な検索
  - "medium": 中程度の探索
  - "very thorough": 複数の場所と命名規則を含む包括的な分析

**選択ガイドライン**:

| タスクの種類 | 推奨タイプ | 理由 |
|------------|----------|------|
| コードベース探索 | Explore | 高速で効率的 |
| ファイル検索 | Explore | パターンマッチングに最適化 |
| Web調査が必要 | general-purpose | WebSearch/WebFetch利用可能 |
| ファイル作成/編集 | general-purpose | Write/Edit権限が必要 |
| 複雑な実装 | general-purpose | すべてのツール利用可能 |
| キーワード検索 | Explore | Grepに最適化 |

### ステップ3: タスク記述の作成

効果的なタスク記述を作成します。サブエージェントは自律的に動作するため、明確で詳細な指示が重要です。

**タスク記述に含めるべき内容**:

1. **明確な目的**:
   ```
   良い例: "React コンポーネントで使用されている状態管理パターンを調査し、
           使用されているライブラリ（Context API, Redux, Zustand等）と
           それぞれの使用箇所を特定してください。"

   悪い例: "状態管理を調べて"
   ```

2. **具体的な手順**（複雑なタスクの場合）:
   ```
   1. src/ ディレクトリ内のすべての .tsx ファイルを検索
   2. useState, useContext, useRedux等のフックを探す
   3. 各パターンの使用頻度を集計
   4. ファイルパスと行番号を含むレポートを作成
   ```

3. **期待される成果物**:
   ```
   最終的に以下の形式でレポートを返してください：
   - 発見された状態管理パターンのリスト
   - 各パターンの使用箇所（ファイルパス:行番号）
   - 推奨事項または発見した問題点
   ```

4. **制約や注意事項**:
   ```
   注意:
   - テストファイル（*.test.tsx）は除外してください
   - node_modules/ ディレクトリは無視してください
   - 外部ライブラリの型定義は含めないでください
   ```

5. **コンテキスト情報**:
   ```
   コンテキスト:
   このプロジェクトは Next.js アプリケーションで、
   現在 Redux から Context API への移行を検討しています。
   ```

**タスク記述のテンプレート**:

```
タスク: [具体的なタスク名]

目的:
[何を達成する必要があるか]

手順:
1. [ステップ1]
2. [ステップ2]
3. [ステップ3]

期待される成果物:
[どのような形式で何を返すべきか]

制約:
- [制約1]
- [制約2]

コンテキスト:
[背景情報や関連情報]
```

### ステップ4: サブエージェントの起動

`Task`ツールを使用してサブエージェントを起動します。

**基本的な起動方法**:

```
Task tool parameters:
- description: "状態管理パターンの調査"（3-5単語の簡潔な説明）
- prompt: [ステップ3で作成した詳細なタスク記述]
- subagent_type: "Explore" または "general-purpose"
```

**複数のサブエージェントを並列実行する場合**:

1つのメッセージで複数の`Task`ツール呼び出しを行います：

```
例: コンポーネント分析とパフォーマンス分析を並列実行

Task 1:
- description: "コンポーネント構造分析"
- subagent_type: "Explore"
- prompt: "src/components/ 内のコンポーネント構造を分析..."

Task 2:
- description: "パフォーマンス問題の検出"
- subagent_type: "Explore"
- prompt: "パフォーマンス問題の可能性があるパターンを検索..."
```

### ステップ5: 結果の取得と報告

サブエージェントが完了したら、結果を取得して報告します。

**結果の処理**:

1. **結果の確認**:
   - サブエージェントは最終メッセージで結果を返します
   - 結果はユーザーには直接表示されません

2. **結果の要約**:
   - 重要な発見を抽出
   - ユーザーにとって有用な情報に焦点を当てる
   - 具体的なファイルパスや行番号を含める

3. **ユーザーへの報告**:
   - 簡潔な要約をユーザーに送信
   - 必要に応じて詳細を提供
   - 次のステップを提案

**報告テンプレート**:

```text
サブエージェント実行完了

タスク: [タスク名]
実行時間: [推定時間]

主要な発見:
- [発見1]
- [発見2]
- [発見3]

詳細:
[必要に応じて詳細情報]

次のステップ:
[推奨される次のアクション]
```

## ベストプラクティス

### タスク設計の原則

1. **明示的なオーケストレーション**:
   - どのステップをサブエージェントに委任するか明示的に指定
   - 暗黙的な判断に頼らず、詳細な委任指示を提供
   - プランニング優先：実行前に計画を立て、ユーザーの確認を得る

2. **タスクグループ化**:
   - 関連タスクをまとめる方が効率的（トークンコストとパフォーマンスのバランス）
   - すべての操作に個別エージェントを作成しない
   - 30秒ルール：1タスク30秒超える場合のみ分解

3. **プロンプト設計**:
   - **ルールより例**: エッジケースの列挙より、多様な例を提供
   - **シンプルで明確**: 専門用語を避け、簡潔な言語を使用
   - **コンテキスト豊富**: 関連情報を多く提供（モデルは必要な情報を見つけられる）
   - **ペルソナ定義**: サブエージェントの役割を明確に定義

4. **自己完結性**:
   - すべての必要情報をタスク記述に含める
   - サブエージェントは追加質問できない
   - 期待される成果物を具体的に指定

### サブエージェントタイプの選択

1. **Explore優先**: コードベース探索には高速なExploreを使用
2. **ツール要件**: WebSearch/WebFetch必要時はgeneral-purposeを選択
3. **効率性**: タスクに必要な最小限のツールセットを持つタイプを選択

### 並列実行の最適化

1. **独立性の確保**: タスク間に依存関係がないことを確認
2. **最大10タスク**: 並列実行上限を考慮
3. **時間短縮**: 5分タスクを30秒に短縮可能
4. **1メッセージで実行**: 並列タスクは単一メッセージで呼び出し

### コンテキスト管理

1. **定期的なリセット**: 長いセッションでは`/clear`を使用
2. **要約重視**: サブエージェントの詳細な結果を1-2千トークンに要約
3. **透明性**: ユーザーに実行内容を明確に伝える

## サブエージェントタイプ別の使用例

### 例1: Exploreエージェント - コードベース探索

**ユーザーリクエスト**: "このプロジェクトでAPIエンドポイントがどのように定義されているか調べて"

**期待される動作**:

1. タスク要件の明確化:
   - 目的: APIエンドポイントの定義場所と方法を特定
   - タスク種類: リサーチ/探索
   - 実行環境: 同期実行

2. サブエージェントタイプ選択:
   - **Explore** を選択（コードベース探索に最適）
   - 徹底度: "medium"

3. タスク記述の作成:
   ```
   タスク: APIエンドポイント定義の調査

   目的:
   プロジェクト内でAPIエンドポイントがどのように定義され、
   実装されているかを特定してください。

   手順:
   1. ルーティング関連のファイルを検索（routes, api, endpointsなど）
   2. HTTPメソッド（GET, POST, PUT, DELETE）の定義を探す
   3. 使用されているフレームワークやライブラリを特定
   4. エンドポイントのパターンと構造を分析

   期待される成果物:
   - 発見されたエンドポイント定義ファイルのリスト（パス付き）
   - 使用されているフレームワーク/ライブラリ
   - エンドポイントの定義パターン
   - 主要なエンドポイントの例（3-5個）

   制約:
   - node_modules/ と .git/ は除外
   - テストファイルとモックは別途記載
   ```

4. サブエージェント起動:
   - description: "APIエンドポイント定義調査"
   - subagent_type: "Explore"
   - prompt: [上記のタスク記述]

5. 結果報告:
   ```
   APIエンドポイント調査完了

   主要な発見:
   - Express.js を使用してエンドポイントを定義
   - エンドポイント定義: src/routes/ ディレクトリ
   - 主要ファイル:
     - src/routes/api/users.ts:10-45 (ユーザー関連エンドポイント)
     - src/routes/api/posts.ts:8-62 (投稿関連エンドポイント)
   - RESTful パターンに従った構造

   詳細情報が必要な場合は、特定のエンドポイントについて
   さらに詳しく調査できます。
   ```

### 例2: general-purposeエージェント - Web調査と実装

**ユーザーリクエスト**: "最新のNext.js 15の機能を調査して、プロジェクトで使えるものをリストアップして"

**期待される動作**:

1. タスク要件の明確化:
   - 目的: Next.js 15の新機能を調査し、プロジェクトへの適用可能性を評価
   - タスク種類: Web調査 + 分析
   - 実行環境: 同期実行

2. サブエージェントタイプ選択:
   - **general-purpose** を選択（WebSearchが必要）

3. タスク記述の作成:
   ```
   タスク: Next.js 15 新機能の調査と評価

   目的:
   Next.js 15の新機能を調査し、現在のプロジェクトで
   活用できる機能を特定してください。

   手順:
   1. Next.js 15の公式ドキュメントをWebSearchで検索
   2. 主要な新機能をリストアップ
   3. 各機能の利点と使用例を調査
   4. 現在のプロジェクト構成と比較（package.json等を確認）
   5. 適用可能な機能を優先順位付け

   期待される成果物:
   - Next.js 15の新機能リスト（各機能の簡潔な説明付き）
   - 現在のプロジェクトで使用可能な機能（優先順位付き）
   - 各機能の導入に必要な手順の概要
   - 導入時の注意点や制約

   制約:
   - 公式ドキュメントまたは信頼できる情報源を優先
   - 実験的機能は別途記載
   - ブレイキングチェンジに注意

   コンテキスト:
   現在 Next.js 14 を使用中。段階的な移行を検討。
   ```

4. サブエージェント起動:
   - description: "Next.js 15新機能調査"
   - subagent_type: "general-purpose"
   - prompt: [上記のタスク記述]

5. 結果報告:
   ```
   Next.js 15 調査完了

   主要な新機能:
   1. React 19 サポート（優先度: 高）
   2. Turbopack 安定版（優先度: 高）
   3. 改善された画像最適化（優先度: 中）
   4. 新しいキャッシング戦略（優先度: 中）
   5. Server Actions の拡張（優先度: 低）

   プロジェクトへの適用可能性:
   - すぐに適用可能: Turbopack（ビルド速度向上）
   - テスト後に適用: React 19サポート
   - 段階的に導入: 新しいキャッシング戦略

   次のステップ:
   1. package.json の更新計画を立てる
   2. Turbopack の導入テスト
   3. React 19 の互換性確認
   ```

### 例3: 並列実行 - 複数のサブエージェント

**ユーザーリクエスト**: "コンポーネントの構造とパフォーマンス問題を同時に調査して"

**期待される動作**:

1. タスク要件の明確化:
   - 目的: コンポーネント分析（構造 + パフォーマンス）
   - タスク種類: 複数の独立したリサーチタスク
   - 実行環境: 並列実行

2. サブエージェントタイプ選択:
   - 両方とも **Explore** を選択（コードベース探索）

3. タスク記述の作成（2つ）:

   **タスク1: コンポーネント構造**
   ```
   タスク: コンポーネント構造の分析

   目的:
   プロジェクト内のReactコンポーネントの構造と
   組織化パターンを分析してください。

   手順:
   1. src/components/ 内のすべての .tsx/.jsx ファイルを検索
   2. コンポーネントの種類を分類（関数/クラス、プレゼンテーション/コンテナ）
   3. コンポーネント間の依存関係を特定
   4. ファイル/フォルダ構造のパターンを分析

   期待される成果物:
   - コンポーネント総数と種類別の内訳
   - 主要なコンポーネントのリスト（パス付き）
   - 構造のパターンと特徴
   - 改善提案（あれば）
   ```

   **タスク2: パフォーマンス問題**
   ```
   タスク: パフォーマンス問題の検出

   目的:
   Reactコンポーネント内の潜在的なパフォーマンス問題を
   特定してください。

   手順:
   1. 大きなコンポーネント（200行以上）を検索
   2. useEffect の依存配列の問題を探す
   3. 不要な再レンダリングの原因を特定
   4. メモ化（useMemo, useCallback）の使用状況を確認

   期待される成果物:
   - 潜在的なパフォーマンス問題のリスト
   - 問題のあるコード箇所（ファイル:行番号）
   - 各問題の深刻度評価
   - 修正の優先順位と推奨事項
   ```

4. サブエージェント起動（並列）:

   **1つのメッセージで2つのTaskツールを呼び出す**:

   Task 1:
   - description: "コンポーネント構造分析"
   - subagent_type: "Explore"
   - prompt: [タスク1の記述]

   Task 2:
   - description: "パフォーマンス問題検出"
   - subagent_type: "Explore"
   - prompt: [タスク2の記述]

5. 結果報告:
   ```
   コンポーネント分析完了（並列実行）

   【構造分析の結果】
   - 総コンポーネント数: 47個
   - 関数コンポーネント: 45個、クラスコンポーネント: 2個
   - 主要なパターン: Atomic Design に基づく構造
   - 改善提案: 一部のコンポーネントが大きすぎる（分割推奨）

   【パフォーマンス分析の結果】
   - 検出された問題: 8件
   - 高優先度: 3件
     - src/components/Dashboard.tsx:156 (不適切なuseEffect依存配列)
     - src/components/UserList.tsx:89 (メモ化なしの高頻度再計算)
     - src/components/Chart.tsx:203 (大量データの非効率な処理)
   - 中優先度: 5件

   次のステップ:
   1. 高優先度の問題から修正を開始
   2. 大きなコンポーネントの分割を検討
   3. パフォーマンステストの実施
   ```

## エラー処理

### タスクが不明確な場合

1. ユーザーに具体的な質問をする
2. 類似タスクの例を提供
3. タスクを分割することを提案

**例**:

```text
タスクの内容が広範すぎるようです。以下のいずれかに焦点を
絞っていただけますか？

1. コンポーネントの構造のみ
2. 状態管理パターンのみ
3. パフォーマンス問題のみ

または、すべてを別々のサブエージェントで並列実行することも可能です。
```

### 適切なサブエージェントタイプが不明な場合

1. タスクの詳細を確認
2. 必要なツールを特定
3. 最適なタイプを推奨

**例**:

```text
このタスクには Web検索が必要になる可能性があります。
以下のどちらを希望しますか？

1. Exploreエージェント（コードベースのみを調査、高速）
2. general-purposeエージェント（Web検索も含む、包括的）
```

### サブエージェントが失敗した場合

1. エラーメッセージを分析
2. タスク記述を調整
3. 必要に応じて再実行または分割

**例**:

```text
サブエージェントがタイムアウトしました。
タスクが大きすぎる可能性があります。

以下のように分割して再実行しますか？

1. タスク1: 基本的な探索
2. タスク2: 詳細な分析
```

### 結果が期待と異なる場合

1. タスク記述の明確化
2. 追加の制約を指定
3. サブエージェントタイプの変更を検討

**例**:

```text
結果がテストファイルを含んでいます。
タスク記述を更新して再実行しますか？

更新案:
制約に「テストファイル（*.test.tsx）を除外」を追加
```

## ツール使用ガイドライン

### Taskツール

- **description**: 3-5単語の簡潔な説明（必須）
- **prompt**: 詳細なタスク記述（必須）
- **subagent_type**: "general-purpose" または "Explore"（必須）

### 並列実行のベストプラクティス

1. **独立性の確認**: タスク間に依存関係がないことを確認
2. **1メッセージで実行**: 複数のTaskツール呼び出しを1つのメッセージに含める
3. **結果の統合**: すべての結果を統合して報告

### サブエージェントとの通信

- サブエージェントは自律的に動作
- 追加の質問やメッセージは送信できない
- すべての情報をタスク記述に含める必要がある

## 品質チェックリスト

サブエージェントを起動する前に以下を確認:

- [ ] タスクの目的が明確に定義されている
- [ ] 適切なサブエージェントタイプを選択している
- [ ] タスク記述が詳細で曖昧さがない
- [ ] 期待される成果物が明記されている
- [ ] 制約や注意事項が含まれている
- [ ] 並列実行の場合、タスクが独立している
- [ ] description が簡潔（3-5単語）
- [ ] サブエージェントが必要な全情報を持っている

## 重要な注意事項

### 実行時の制約

1. **完全自律**: サブエージェントは追加の指示やフィードバックを受け取れない
2. **ステートレス**: 前のタスクの結果や会話履歴にアクセスできない
3. **30秒ルール**: 長時間タスクは必ず分解（目安: 30秒以内）
4. **並列上限**: 最大10タスク同時実行

### 設計時の考慮事項

1. **明示的オーケストレーション**: Claudeは慎重にTaskを使用するため、詳細な委任指示が必要
2. **タスクグループ化**: トークンコストとパフォーマンスのバランスを考慮
3. **コンテキスト効率**: ツール定義はコンテキストで目立つため、適切なツール選択が重要
4. **例ベースの設計**: ルールの列挙より、多様な例で期待動作を示す

### ユーザーとのコミュニケーション

1. **透明性**: 何が起こっているか明確に伝える
2. **プランニング**: 実行前に計画をユーザーに確認
3. **要約**: サブエージェントの結果を簡潔に要約
4. **次のステップ**: フォローアップアクションを提案

### 品質保証

1. **結果の検証**: サブエージェントの出力を批判的に評価
2. **エラー処理**: 失敗時の再試行戦略を持つ
3. **柔軟性**: タスク記述が期待と異なる結果を生む場合は調整

## 参考情報

- Claude Code 公式ドキュメント: <https://docs.claude.com/en/docs/claude-code>
- サブエージェント詳細: <https://docs.claude.com/en/docs/claude-code/sub-agents>
- ベストプラクティス: <https://www.anthropic.com/engineering/claude-code-best-practices>
- エージェント設計: <https://www.anthropic.com/engineering/building-agents-with-the-claude-agent-sdk>
