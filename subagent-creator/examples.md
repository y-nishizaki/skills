# サブエージェント使用例

このドキュメントでは、様々なユースケースにおけるサブエージェントの実用的な使用例を提供します。

## 目次

1. [コードベース探索](#コードベース探索)
2. [Web調査とリサーチ](#web調査とリサーチ)
3. [並列実行パターン](#並列実行パターン)
4. [複雑なタスクの分解](#複雑なタスクの分解)
5. [エラー処理と再試行](#エラー処理と再試行)

## コードベース探索

### 例1: 認証フローの調査

**ユーザーリクエスト**: "このプロジェクトの認証フローを調査して"

**サブエージェント設計**:

```
エージェントタイプ: Explore
徹底度: medium

タスク記述:
"""
あなたはセキュリティエンジニアです。このプロジェクトの認証フローを
包括的に調査し、レポートを作成してください。

調査項目:
1. 認証方式の特定（JWT, セッション, OAuth等）
2. ログイン/ログアウトフローの実装箇所
3. 認証ミドルウェアやガードの使用状況
4. トークン管理（保存、検証、更新）
5. セキュリティ上の懸念事項

調査手順:
1. 認証関連のファイルを検索（auth, login, session等のキーワード）
2. ミドルウェアやルートガードを特定
3. トークン生成・検証のコードを分析
4. 認証フローを図解または説明

成果物:
- 使用されている認証方式（詳細説明付き）
- 主要な認証関連ファイルのリスト（ファイルパス:行番号）
- 認証フローの説明（ステップバイステップ）
- セキュリティ上の推奨事項や発見した問題点

制約:
- node_modules/, .git/, dist/は除外
- テストファイルは別途記載
- 環境変数名は言及するが値は含めない
"""
```

**期待される結果要約**:

```
認証フロー調査完了

【認証方式】
- JWT（JSON Web Token）ベースの認証
- リフレッシュトークンによる自動更新機能あり

【主要ファイル】
- src/middleware/auth.ts:15-89 (認証ミドルウェア)
- src/services/auth-service.ts:45-230 (トークン生成・検証)
- src/routes/auth.ts:10-150 (ログイン/ログアウトエンドポイント)
- src/utils/token.ts:8-67 (トークンユーティリティ)

【認証フロー】
1. ユーザーがログイン（POST /api/auth/login）
2. 認証情報を検証
3. アクセストークン（15分有効）とリフレッシュトークン（7日有効）を発行
4. トークンをHTTP-onlyクッキーに保存
5. 保護されたルートでミドルウェアがトークンを検証
6. トークン期限切れ時、リフレッシュトークンで自動更新

【セキュリティ推奨事項】
✓ HTTP-onlyクッキー使用（XSS対策）
✓ CSRF トークン実装済み
! トークンのブラックリスト機能なし（ログアウト時の即時無効化不可）
! レート制限が未実装（ブルートフォース攻撃リスク）
```

### 例2: パフォーマンスボトルネックの検出

**ユーザーリクエスト**: "パフォーマンスに問題がありそうなコードを見つけて"

**サブエージェント設計**:

```
エージェントタイプ: Explore
徹底度: very thorough

タスク記述:
"""
あなたはパフォーマンスエンジニアです。コードベース内のパフォーマンス
ボトルネックとなりうるパターンを特定してください。

検索パターン:
1. N+1クエリ問題（ループ内のデータベースクエリ）
2. 同期的なI/O操作（await なしのファイル操作等）
3. 大量データの非効率な処理（メモリに全ロード）
4. 不要な再計算（React: メモ化なし、ループ内の重い計算）
5. 未最適化のデータベースクエリ（インデックスなし）

調査手順:
1. ループ内のデータベースクエリを検索
2. ファイルI/O、ネットワークリクエストの同期操作を探す
3. 大きな配列・オブジェクトの処理を特定
4. Reactコンポーネントのメモ化状況を確認
5. データベーススキーマとクエリを分析

成果物:
- パフォーマンス問題のカテゴリ別リスト
- 各問題の深刻度（高/中/低）
- 問題箇所（ファイルパス:行番号）
- 修正提案と推定される改善効果

制約:
- 実測値でなく、コードパターンベースの分析
- サードパーティライブラリ内のコードは除外
- テストコードは低優先度
"""
```

## Web調査とリサーチ

### 例3: 技術スタックの最新動向調査

**ユーザーリクエスト**: "Next.js 15とReact 19の新機能を調査して、移行計画を提案して"

**サブエージェント設計**:

```
エージェントタイプ: general-purpose

タスク記述:
"""
あなたは技術アドバイザーです。Next.js 15とReact 19の新機能を調査し、
現在のプロジェクトへの移行計画を提案してください。

調査内容:
1. Next.js 15の主要な新機能とブレイキングチェンジ
2. React 19の新機能とベストプラクティス
3. 現在のプロジェクトとの互換性分析
4. 段階的な移行計画

調査手順:
1. 公式ドキュメントをWebSearchで検索
2. 主要な新機能をリストアップ
3. ブレイキングチェンジを特定
4. 現在のpackage.jsonを確認
5. 移行に必要なステップを整理
6. リスクと対策を評価

成果物:
- 新機能の詳細リスト（優先度付き）
- ブレイキングチェンジと影響範囲
- 段階的移行計画（フェーズ1-3）
- 各フェーズのリスク評価と対策
- 推定工数と優先順位

コンテキスト:
- 現在: Next.js 14.0.3, React 18.2.0
- プロジェクト規模: 中規模（50+ コンポーネント）
- ダウンタイム許容: 最小限
"""
```

### 例4: ライブラリの選定調査

**ユーザーリクエスト**: "状態管理ライブラリを比較して、最適なものを提案して"

**サブエージェント設計**:

```
エージェントタイプ: general-purpose

タスク記述:
"""
あなたはReact開発のエキスパートです。現在主流の状態管理ライブラリを
比較し、このプロジェクトに最適なものを推奨してください。

比較対象:
1. Redux Toolkit
2. Zustand
3. Jotai
4. Recoil
5. React Context API + useReducer

比較軸:
- 学習曲線
- バンドルサイズ
- パフォーマンス
- 開発者体験
- TypeScript サポート
- ミドルウェア/拡張性
- コミュニティとエコシステム

調査手順:
1. 各ライブラリの最新情報をWebSearchで収集
2. GitHub スター数、メンテナンス状況を確認
3. バンドルサイズを比較
4. 現在のプロジェクトの要件を分析
5. 各ライブラリのメリット/デメリットを整理

成果物:
- ライブラリ比較表（Markdown形式）
- 各ライブラリの評価（5段階）
- プロジェクトに最適な選択肢（1-2個）
- 選択理由の詳細説明
- 導入サンプルコード

コンテキスト:
- プロジェクト: Next.js 14 アプリケーション
- チーム: 3-5人の開発者（React経験あり）
- 要件: TypeScript必須、パフォーマンス重視
"""
```

## 並列実行パターン

### 例5: 多面的なコード品質分析

**ユーザーリクエスト**: "コードベース全体の品質を分析して"

**サブエージェント設計（3つ並列実行）**:

**タスク1: コード複雑度分析**
```
エージェントタイプ: Explore
徹底度: medium

タスク記述:
"""
コードの複雑度とメンテナンス性を分析してください。

分析項目:
1. 大きな関数/メソッド（50行以上）
2. 深いネスト（4レベル以上）
3. 高い循環的複雑度
4. 長いファイル（300行以上）

成果物:
- 複雑度が高いファイルのリスト（上位10個）
- 各ファイルの問題点と推奨リファクタリング
- 全体的な複雑度スコア
"""
```

**タスク2: 依存関係分析**
```
エージェントタイプ: Explore
徹底度: medium

タスク記述:
"""
モジュール間の依存関係を分析してください。

分析項目:
1. 循環依存の検出
2. 疎結合度の評価
3. 未使用の依存関係
4. バージョンの一貫性

成果物:
- 循環依存のリスト（あれば）
- 高度に結合されたモジュール
- 未使用パッケージのリスト
- 更新が必要なパッケージ
"""
```

**タスク3: テストカバレッジ分析**
```
エージェントタイプ: Explore
徹底度: quick

タスク記述:
"""
テストの状況を分析してください。

分析項目:
1. テストファイルの有無
2. テストされていないモジュール
3. テストの種類（unit, integration, e2e）
4. モックの使用状況

成果物:
- テストカバレッジの推定
- テストが不足しているモジュール（上位10個）
- 推奨されるテスト追加箇所
"""
```

**並列実行**:
```
1つのメッセージで3つのTaskツールを同時に呼び出す

実行時間: 単独だと約2-3分 → 並列実行で約30-40秒
```

### 例6: マルチソースリサーチ

**ユーザーリクエスト**: "GraphQLの導入可否を検討して"

**サブエージェント設計（2つ並列実行）**:

**タスク1: GraphQL最新情報調査**
```
エージェントタイプ: general-purpose

タスク記述:
"""
GraphQLの最新動向、ベストプラクティス、主要ツールを調査してください。

調査内容:
- GraphQL 2024-2025のトレンド
- 推奨されるサーバー実装（Apollo, GraphQL Yoga等）
- クライアントライブラリ（Apollo Client, urql, React Query等）
- パフォーマンス最適化手法
- セキュリティベストプラクティス

成果物:
- 最新のGraphQLエコシステム概要
- 推奨ツールとライブラリ
- ベストプラクティス集
"""
```

**タスク2: 現在のREST API分析**
```
エージェントタイプ: Explore
徹底度: medium

タスク記述:
"""
現在のREST APIの構造を分析し、GraphQL移行の影響を評価してください。

分析内容:
- エンドポイント数と種類
- データフェッチングパターン
- オーバーフェッチング/アンダーフェッチングの箇所
- 複雑な関連データ取得

成果物:
- REST API の現状サマリー
- GraphQL化のメリットがある箇所
- 移行の難易度評価
- 段階的移行の可能性
"""
```

## 複雑なタスクの分解

### 例7: 大規模リファクタリングの計画

**ユーザーリクエスト**: "クラスコンポーネントを関数コンポーネントに移行したい"

**フェーズ1: 調査（サブエージェント1）**
```
エージェントタイプ: Explore
徹底度: very thorough

タスク記述:
"""
すべてのクラスコンポーネントを特定し、移行の複雑度を評価してください。

調査項目:
1. クラスコンポーネントのリスト作成
2. 各コンポーネントの複雑度評価
3. 使用されているライフサイクルメソッド
4. 依存関係の分析

成果物:
- クラスコンポーネントの全リスト（ファイルパス付き）
- 移行難易度別の分類（簡単/中程度/困難）
- 各コンポーネントの特徴（ライフサイクル、状態管理等）
- 推奨移行順序
"""
```

**フェーズ2: パイロット移行（手動実行後、サブエージェント2）**
```
ユーザーが簡単なコンポーネント1つを手動で移行した後：

エージェントタイプ: Explore
徹底度: quick

タスク記述:
"""
移行したコンポーネントをレビューし、パターンを抽出してください。

レビュー内容:
1. 移行パターンの確認
2. 発生した問題の特定
3. テストの適合性確認

成果物:
- 移行パターンのテンプレート
- 注意すべきポイント
- 残りのコンポーネントへの適用可能性
"""
```

### 例8: セキュリティ監査

**30秒ルールに従った分解**:

このタスクは大きいため、3つのサブタスクに分解：

**タスク1: 認証・認可の監査（30秒以内）**
```
エージェントタイプ: Explore

- 認証フローの確認
- 権限チェックの実装確認
- セッション管理の評価
```

**タスク2: 入力検証とサニタイゼーション（30秒以内）**
```
エージェントタイプ: Explore

- ユーザー入力の検証箇所
- SQLインジェクション対策
- XSS対策の確認
```

**タスク3: 依存関係の脆弱性（30秒以内）**
```
エージェントタイプ: Explore

- package.jsonの確認
- 既知の脆弱性チェック
- 更新が必要なパッケージ
```

これらを並列実行することで、本来3分のタスクを30-40秒で完了。

## エラー処理と再試行

### 例9: タイムアウト発生時の対応

**初回試行（失敗）**:
```
エージェントタイプ: Explore
徹底度: very thorough

タスク記述: "全プロジェクトのすべてのTODOコメントを集計して..."

結果: タイムアウト（30秒超過）
```

**再試行（分解）**:
```
タスク1: src/ ディレクトリのTODO検索
タスク2: tests/ ディレクトリのTODO検索
タスク3: 集計と優先順位付け

各タスクを順次実行（並列でも可）
```

### 例10: 期待と異なる結果への対応

**初回試行**:
```
タスク記述: "エラーハンドリングを確認"

結果: テストファイルのエラーハンドリングも含まれてしまった
```

**調整後の再試行**:
```
タスク記述を更新:

"""
エラーハンドリングを確認してください。

制約:
- テストファイル（*.test.*, *.spec.*）は除外
- モックやスタブも除外
- 本番コードのエラーハンドリングのみが対象

重点箇所:
- try-catchブロック
- Promiseの.catch()
- エラーバウンダリ（React）
- グローバルエラーハンドラ
"""
```

## プロンプト設計のベストプラクティス

### Good vs Bad プロンプト例

**Bad（曖昧）**:
```
"コードを調べて問題を見つけて"
```

**Good（具体的、ペルソナあり）**:
```
"""
あなたはシニアコードレビュアーです。このプロジェクトのコード品質を
以下の観点から分析してください：

1. コーディング規約違反（ESLint、Prettier設定に基づく）
2. セキュリティ上の懸念（OWASP Top 10）
3. パフォーマンス問題
4. メンテナンス性の問題

各問題について：
- 箇所（ファイルパス:行番号）
- 問題の説明
- 深刻度（高/中/低）
- 修正提案

成果物はMarkdownの表形式で提供してください。
"""
```

**Bad（ルール列挙）**:
```
"以下のルールに従ってコードをチェック：
1. 変数名は camelCase
2. 関数は50行以内
3. コメントは必須
4. ... (20個のルール)"
```

**Good（例ベース）**:
```
"""
以下のようなコードパターンを探してください：

良い例:
const userName = getUserName(); // 明確な命名、適切な長さ

悪い例:
const x = getData(); // 曖昧な命名
function processEverything() { // 巨大な関数（200行）
  ...
}

このパターンに基づいて、改善が必要なコードを特定してください。
"""
```

## まとめ

### サブエージェント活用の鍵

1. **明確な委任**: 何を、どのように、どんな形式で返すか明示
2. **適切な分解**: 30秒ルールを守り、大きなタスクは分割
3. **並列化**: 独立したタスクは同時実行で効率化
4. **例の活用**: ルールより例で期待動作を示す
5. **ペルソナ設定**: サブエージェントの役割を明確に
6. **豊富なコンテキスト**: 関連情報を積極的に提供

これらのパターンを組み合わせることで、サブエージェントを効果的に活用できます。
