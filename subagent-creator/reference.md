# サブエージェント作成リファレンス

このドキュメントは、サブエージェント作成の技術的な詳細とリファレンス情報を提供します。

## Taskツールの仕様

### 必須パラメータ

#### description

- **型**: string
- **形式**: 3-5単語の簡潔な説明
- **目的**: タスクの概要を短く表現
- **例**:
  - "コンポーネント構造分析"
  - "APIエンドポイント調査"
  - "パフォーマンス問題検出"

#### prompt

- **型**: string
- **形式**: 詳細なタスク記述（制限なし）
- **目的**: サブエージェントが自律的に実行するための完全な指示
- **推奨構造**:

  ```
  [ペルソナ設定]
  あなたは[役割]です。

  [タスクの目的]
  [何を達成する必要があるか]

  [調査/分析項目]
  1. [項目1]
  2. [項目2]

  [手順]（オプション、複雑なタスクの場合）
  1. [ステップ1]
  2. [ステップ2]

  [成果物]
  [期待される出力形式と内容]

  [制約]
  - [制約1]
  - [制約2]

  [コンテキスト]（オプション）
  [背景情報や関連情報]
  ```

#### subagent_type

- **型**: string (enum)
- **値**:
  - `"general-purpose"`: 汎用エージェント
  - `"Explore"`: コードベース探索特化エージェント
- **選択基準**: [サブエージェントタイプの選択](#サブエージェントタイプの選択)参照

## サブエージェントタイプの選択

### general-purpose

**特徴**:

- すべてのツールにアクセス可能
- 最も柔軟で汎用的
- トークン使用量が多い可能性

**利用可能なツール**:

- Read, Write, Edit
- Bash
- Glob, Grep
- WebSearch, WebFetch
- その他すべての標準ツール

**適したタスク**:

- Web調査が必要
- ファイルの作成・編集が必要
- 複雑なマルチステップタスク
- 外部情報の取得が必要

**使用例**:

```
subagent_type: "general-purpose"

タスク例:
- "最新のTypeScript 5.x機能を調査し、プロジェクトで使えるものをリストアップ"
- "新しい機能モジュールを実装（ファイル作成、テスト追加含む）"
- "パッケージの脆弱性をWebで調査し、更新計画を提案"
```

### Explore

**特徴**:

- コードベース探索に特化
- 高速で効率的
- 限定的なツールセット
- 徹底度レベルを指定可能

**利用可能なツール**:

- Glob: ファイルパターン検索
- Grep: コンテンツ検索
- Read: ファイル読み取り
- Bash: シェルコマンド実行

**徹底度レベル**:

- `"quick"`: 基本的な検索のみ
  - 使用例: 特定のファイルやパターンを素早く見つける
  - 実行時間: 10-15秒
- `"medium"`: 中程度の探索
  - 使用例: 複数の場所を調査、基本的な分析
  - 実行時間: 20-30秒
- `"very thorough"`: 包括的な分析
  - 使用例: 複数の命名規則、深い階層構造の探索
  - 実行時間: 30秒前後（30秒超える場合は分解推奨）

**適したタスク**:

- ファイルパターンの検索
- キーワードによるコード検索
- コードベースの構造分析
- 既存コードの調査

**使用例**:

```
subagent_type: "Explore"

タスク例:
- "src/components/ 内のすべてのReactコンポーネントを分類"
- "TODOコメントを全て抽出してリスト化"
- "未使用のimport文を検出"
```

### タイプ選択フローチャート

```
タスクを実行する
    ↓
Web検索やWebフェッチが必要？
    ↓ Yes → general-purpose
    ↓ No
ファイルの作成・編集が必要？
    ↓ Yes → general-purpose
    ↓ No
コードベースの探索・検索のみ？
    ↓ Yes → Explore
    ↓ No
複雑なマルチステップタスク？
    ↓ Yes → general-purpose
    ↓ No
    → Explore（デフォルト、高速）
```

## プロンプト設計パターン

### パターン1: リサーチタスク

**構造**:

```
あなたは[専門家の役割]です。

[調査対象]について包括的にリサーチしてください。

調査項目:
1. [項目1]
2. [項目2]
3. [項目3]

調査手順:
1. [情報源の特定]
2. [データの収集]
3. [分析と整理]
4. [結論の導出]

成果物:
- [アウトプット1]
- [アウトプット2]
形式: [Markdown/表/リスト等]

制約:
- [情報源の制限]
- [除外項目]
- [優先順位]
```

**例**:

```
あなたはReactパフォーマンスエンジニアです。

このプロジェクトのReactコンポーネントのパフォーマンス最適化の
機会を調査してください。

調査項目:
1. 不要な再レンダリング
2. メモ化の機会
3. コンポーネント分割の必要性
4. 仮想化の必要性

調査手順:
1. すべての.tsx/.jsxファイルを検索
2. useState, useEffect, propsの使用パターンを分析
3. useMemo, useCallback, React.memoの使用状況を確認
4. 大きなリスト・テーブルコンポーネントを特定

成果物:
- パフォーマンス改善の機会リスト（優先度付き）
- 各機会の詳細（ファイルパス:行番号、問題、解決策）
形式: Markdownの表

制約:
- テストファイルは低優先度
- サードパーティコンポーネントは除外
```

### パターン2: 分析タスク

**構造**:

```
あなたは[分析者の役割]です。

[対象]を以下の観点から分析してください。

分析観点:
1. [観点1]: [詳細]
2. [観点2]: [詳細]

分析手法:
- [手法1]
- [手法2]

成果物:
各観点について:
- 現状
- 問題点
- 推奨事項
- 優先順位

形式: [構造化されたレポート]
```

**例**:

```
あなたはソフトウェアアーキテクトです。

このプロジェクトのモジュール構造を以下の観点から分析してください。

分析観点:
1. 関心の分離: 各モジュールが単一責任を持っているか
2. 結合度: モジュール間の依存関係の適切性
3. 凝集度: モジュール内の機能の関連性
4. スケーラビリティ: 拡張性の評価

分析手法:
- ディレクトリ構造の調査
- import/export パターンの分析
- モジュールサイズと複雑度の測定

成果物:
各観点について:
- 現状評価（良好/要改善/問題あり）
- 具体的な問題箇所（ファイルパス付き）
- 推奨リファクタリング
- 優先順位（高/中/低）

形式: セクション分けされたMarkdownレポート
```

### パターン3: 検出・収集タスク

**構造**:

```
[対象パターン]を検出してリスト化してください。

検索パターン:
- [パターン1]: [正規表現や説明]
- [パターン2]: [正規表現や説明]

検索範囲:
- [ディレクトリ/ファイルタイプ]

除外:
- [除外項目]

成果物:
- 検出された項目のリスト
  - ファイルパス:行番号
  - コードスニペット
  - [追加情報]

形式: [リスト/表/JSON等]
```

**例**:

```
セキュリティ上問題がありそうなコードパターンを検出してください。

検索パターン:
- ハードコードされたシークレット: APIキー、パスワード、トークン
- SQLインジェクションリスク: 動的なSQLクエリ構築
- XSSリスク: innerHTML、dangerouslySetInnerHTMLの使用
- CSRF対策なし: 状態変更APIエンドポイントのCSRFトークン確認

検索範囲:
- src/ 配下のすべての.ts, .js, .tsx, .jsxファイル

除外:
- テストファイル
- node_modules/
- 環境変数ファイル（.env等）は名前のみ記載

成果物:
各パターンについて:
- 検出件数
- ファイルパス:行番号
- コードスニペット（機密情報はマスク）
- 深刻度（高/中/低）
- 推奨対策

形式: カテゴリ別にグループ化されたMarkdownリスト
```

### パターン4: 比較・評価タスク

**構造**:

```
あなたは[評価者の役割]です。

[対象A]と[対象B]を以下の基準で比較評価してください。

比較基準:
1. [基準1]: [重要度]
2. [基準2]: [重要度]
3. [基準3]: [重要度]

評価方法:
- [定量的指標]
- [定性的指標]

成果物:
- 比較表（各基準での評価）
- 各対象の強み・弱み
- 推奨事項
- 選択理由

形式: Markdownの比較表 + 説明文
```

**例**:

```
あなたはフロントエンドアーキテクトです。

Reactフレームワーク（Next.js vs Remix vs Vite）を
このプロジェクトの要件に基づいて比較評価してください。

比較基準:
1. パフォーマンス: ビルド時間、ランタイム性能（重要度: 高）
2. 開発者体験: Hot reload、TypeScript対応（重要度: 高）
3. エコシステム: プラグイン、コミュニティ（重要度: 中）
4. デプロイ: Vercel、AWS、自己ホスト（重要度: 中）
5. 学習曲線: チームの習得コスト（重要度: 高）

評価方法:
- 公式ドキュメントのWebSearch
- 最新のベンチマーク結果
- コミュニティフィードバック
- 現在のチームスキルとの照合

成果物:
- 5段階評価の比較表
- 各フレームワークの強み・弱み
- プロジェクトに最適な選択（1-2個）
- 選択理由の詳細説明
- 移行コストの見積もり

コンテキスト:
- チーム規模: 5人
- React経験: 中級レベル
- プロジェクト: 中規模B2B SaaS
- 重視: パフォーマンスとSEO

形式: Markdown比較表 + セクション分けされた説明
```

## 並列実行のパターン

### パターン1: 独立した複数調査

**シナリオ**: 関連性はあるが独立した複数の調査タスク

**実装**:

```javascript
// 1つのメッセージで複数のTaskツールを呼び出す

Task 1: フロントエンド分析
Task 2: バックエンド分析
Task 3: データベース分析

// これらは互いに独立しているため並列実行可能
```

**メリット**:

- 各タスク単独: 40秒 × 3 = 120秒
- 並列実行: 最長タスク = 40秒
- 時間短縮: 66%削減

### パターン2: 階層的タスク分解

**シナリオ**: 大きなタスクを階層的に分解

**実装**:

```
フェーズ1: 概要調査（1タスク）
    ↓ 結果を受けて
フェーズ2: 詳細調査（3タスク並列）
    ↓ 結果を受けて
フェーズ3: 統合・提案（1タスク）
```

**例**:

```
フェーズ1: パフォーマンス問題の概要調査
→ 結果: フロントエンド、バックエンド、DBに問題あり

フェーズ2（並列）:
- フロントエンドの詳細分析
- バックエンドの詳細分析
- データベースクエリの詳細分析

フェーズ3: 統合レポートと優先順位付け
```

### パターン3: Map-Reduce型

**シナリオ**: 複数の部分に分割して処理し、結果を統合

**実装**:

```
Map（並列）:
- src/components/ の分析
- src/services/ の分析
- src/utils/ の分析
- src/hooks/ の分析

Reduce（単一タスクまたはメイン）:
- すべての結果を統合
- 全体的なパターンを抽出
- 推奨事項を作成
```

## エラー処理とリカバリー

### エラータイプと対処法

#### 1. タイムアウト

**原因**: タスクが30秒を超えた

**対処**:

```
元のタスク（タイムアウト）:
"全プロジェクトの全TODOコメントを分析"

分解後（成功）:
タスク1: "src/ のTODO検索"
タスク2: "tests/ のTODO検索"
タスク3: "docs/ のTODO検索"

→ 各タスク15秒で完了、並列実行で15秒
```

#### 2. 不完全な結果

**原因**: タスク記述が曖昧

**対処**:

```
元のタスク（不完全）:
"エラーハンドリングを確認"

改善後（完全）:
"""
本番コードのエラーハンドリングを確認してください。

対象:
- try-catchブロック
- Promiseエラーハンドリング
- Reactエラーバウンダリ
- グローバルエラーハンドラ

除外:
- テストファイル（*.test.*, *.spec.*）
- モックコード
- 開発専用コード

成果物に含める:
- エラーハンドリングの箇所（ファイルパス:行番号）
- ハンドリング方法の評価
- 改善提案
"""
```

#### 3. 期待と異なる結果

**原因**: コンテキスト不足

**対処**:

```
元のタスク（コンテキスト不足）:
"パフォーマンスを改善して"

改善後（コンテキスト豊富）:
"""
Reactコンポーネントのレンダリングパフォーマンスを改善してください。

現状の問題:
- ダッシュボードページの初回レンダリングが3秒
- リスト更新時にすべてが再レンダリング
- 100件以上のアイテム表示で遅延

調査箇所:
- src/pages/Dashboard.tsx
- src/components/ItemList.tsx
- src/hooks/useItems.ts

期待される改善:
- 初回レンダリング: 1秒以内
- 部分更新: 即座に反映

提案に含めるべき内容:
- メモ化の機会（useMemo, useCallback, React.memo）
- 仮想化の検討（react-window等）
- データフェッチングの最適化
- 具体的なコード変更案
"""
```

#### 4. ツール権限エラー

**原因**: 不適切なサブエージェントタイプ

**対処**:

```
エラー例:
Explore エージェントでWebSearchを使おうとした

修正:
subagent_type: "Explore" → "general-purpose"
```

### リトライ戦略

#### 戦略1: パラメータ調整

```
1回目（失敗）: Explore + very thorough → タイムアウト
2回目（成功）: Explore + medium → 成功
```

#### 戦略2: タスク分解

```
1回目（失敗）: 1つの大きなタスク → タイムアウト
2回目（成功）: 3つの小タスクに分解 → 各成功
```

#### 戦略3: タイプ変更

```
1回目（失敗）: Explore → Web情報が必要で失敗
2回目（成功）: general-purpose → 成功
```

## パフォーマンス最適化

### 最適化チェックリスト

- [ ] **30秒ルール**: 各タスクは30秒以内
- [ ] **並列化**: 独立タスクは並列実行
- [ ] **適切なタイプ**: Exploreで十分ならgeneral-purposeを使わない
- [ ] **徹底度調整**: very thoroughは必要な時のみ
- [ ] **タスクグループ化**: 小さすぎるタスクは統合
- [ ] **コンテキスト効率**: 不要な情報を除外

### 実行時間の目安

| タスクタイプ | Explore (quick) | Explore (medium) | Explore (very thorough) | general-purpose |
|------------|----------------|-----------------|----------------------|----------------|
| ファイル検索 | 5-10秒 | 10-20秒 | 20-30秒 | 15-30秒 |
| コード分析 | 10-15秒 | 20-30秒 | 30秒+ | 25-40秒 |
| Web調査 | N/A | N/A | N/A | 20-40秒 |
| 実装タスク | N/A | N/A | N/A | 30-60秒+ |

### 並列実行の効果

| タスク数 | 単独実行 | 並列実行 | 短縮率 |
|---------|---------|---------|--------|
| 2タスク | 60秒 | 30秒 | 50% |
| 3タスク | 90秒 | 30秒 | 67% |
| 5タスク | 150秒 | 30秒 | 80% |
| 10タスク | 300秒 | 30秒 | 90% |

*各タスク30秒と仮定、実際は最長タスクの時間になる

## トラブルシューティング

### 問題: サブエージェントが起動しない

**チェック項目**:

1. 必須パラメータ（description, prompt, subagent_type）を指定しているか
2. subagent_typeの値が正しいか（"general-purpose" or "Explore"）
3. promptが空でないか

### 問題: 結果が返ってこない

**可能性**:

1. タイムアウト → タスクを分解
2. エラー発生 → タスク記述を確認
3. 無限ループ → タスク記述を明確化

### 問題: 期待した結果と異なる

**改善方法**:

1. **ペルソナを追加**: "あなたは〜です"
2. **例を提供**: 良い例・悪い例を示す
3. **制約を明示**: 除外項目を列挙
4. **成果物の形式を指定**: Markdown表、リスト、JSON等
5. **コンテキストを追加**: 背景情報を提供

### 問題: パフォーマンスが悪い

**最適化方法**:

1. タスクを並列化
2. Exploreタイプを使用（可能な場合）
3. 徹底度レベルを下げる
4. 不要な調査を除外

## リファレンスリンク

### 公式ドキュメント

- Claude Code: <https://docs.claude.com/en/docs/claude-code>
- サブエージェント: <https://docs.claude.com/en/docs/claude-code/sub-agents>
- スキル: <https://docs.claude.com/en/docs/claude-code/skills.md>

### ベストプラクティス

- Claude Code Best Practices: <https://www.anthropic.com/engineering/claude-code-best-practices>
- Agent SDK: <https://www.anthropic.com/engineering/building-agents-with-the-claude-agent-sdk>
- Context Engineering: <https://www.anthropic.com/engineering/effective-context-engineering-for-ai-agents>

### コミュニティリソース

- ClaudeLog: <https://claudelog.com/mechanics/task-agent-tools/>
- Agent Design: <https://jannesklaas.github.io/ai/2025/07/20/claude-code-agent-design.html>

## 改訂履歴

- v1.0.0 (2025-10-21): 初版リリース
