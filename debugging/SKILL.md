---
name: "デバッグ"
description: "バグ修正・問題解決時の思考プロセス。エラー、バグ、問題、修正、デバッグに関する依頼に対応"
---

# デバッグ: バグ修正・問題解決時の思考プロセス

## このスキルを使う場面

- エラーメッセージが表示されている
- 期待する動作と実際の動作が異なる
- 既存の機能が正常に動作しない
- システムがクラッシュする
- パフォーマンスの異常がある
- データの不整合がある

## 思考プロセス

### フェーズ1: エラー情報の収集と理解

**ステップ1: エラー情報の完全な記録**

以下の情報をすべて収集する：

1. **エラーメッセージ**
   - 完全なエラーテキスト（省略しない）
   - エラーコード（あれば）
   - スタックトレース全体

2. **発生条件**
   - いつ発生するか（常に/時々/特定条件下）
   - どの操作で発生するか
   - どのデータで発生するか

3. **環境情報**
   - OS・バージョン
   - 言語・フレームワークのバージョン
   - 依存ライブラリのバージョン
   - 設定ファイルの内容

4. **最近の変更**
   - 直近のコード変更
   - 設定変更
   - 環境の変更
   - データの変更

**ステップ2: エラーメッセージの正確な読解**

1. **エラータイプの特定**
   - 構文エラー: コードの書き方の問題
   - 型エラー: データ型の不一致
   - 参照エラー: 存在しないものを参照
   - ランタイムエラー: 実行時の予期しない状態
   - 論理エラー: コードは動くが結果が間違い

2. **エラーの場所を特定**
   - どのファイル・関数・行で発生しているか
   - スタックトレースから呼び出し経路を追跡
   - 最も深い（根本的な）エラー発生箇所を特定

3. **エラーの意味を理解**
   - エラーメッセージが何を伝えているか
   - なぜそのエラーが発生したか（推測）
   - 不明な場合はドキュメント・検索で調査

**移行条件:**

- [ ] エラー情報を完全に記録した
- [ ] エラーの意味を理解した
- [ ] 発生条件を把握した

### フェーズ2: 再現手順の確立

**ステップ1: 最小再現ケースの作成**

1. **再現手順を文書化**
   - ステップバイステップの手順
   - 必要なデータ・設定
   - 期待される結果 vs 実際の結果

2. **再現性の確認**
   - 100% 再現できるか
   - 再現率が低い場合、パターンを探す
   - 環境依存かどうか確認

3. **最小化**
   - 不要な要素を削除
   - 最もシンプルな再現方法を見つける
   - 影響する要因を特定

**ステップ2: 再現できない場合の対処**

再現率が低い、または再現できない場合：

1. **ログ・トレースの追加**
   - 詳細なログを追加
   - デバッグ出力を増やす
   - 状態をファイルに記録

2. **環境の違いを調査**
   - 本番環境と開発環境の差
   - タイミング依存の問題
   - 並行処理の問題

3. **統計的アプローチ**
   - 複数回試行して発生パターンを探す
   - 発生条件の共通点を見つける

**移行条件:**

- [ ] 安定して再現できる、またはパターンを把握した
- [ ] 最小再現ケースを作成した

### フェーズ3: 仮説の立案と優先順位付け

**ステップ1: 可能性のある原因をリストアップ**

エラー情報と再現手順から、考えられる原因を列挙：

1. **よくある原因から考える**
   - Null/undefined の参照
   - 型の不一致
   - インデックスの範囲外アクセス
   - 初期化忘れ
   - 非同期処理のタイミング問題

2. **最近の変更を疑う**
   - 直近のコミットを確認
   - 新しく追加した機能
   - 変更したライブラリ

3. **環境・設定を疑う**
   - パス・URL の設定ミス
   - 権限の問題
   - 依存関係の不一致

**ステップ2: 仮説の優先順位付け**

以下の基準で仮説に優先順位をつける：

1. **可能性の高さ**: エラーメッセージと一致する度合い
2. **検証の容易さ**: すぐに確認できるか
3. **影響範囲**: 修正が他に影響しないか
4. **過去の経験**: 似た問題を見たことがあるか

**優先順位の例:**

1. エラーメッセージが直接示している問題
2. 最近変更した箇所
3. よくあるミス（typo、初期化忘れ等）
4. 環境・設定の問題
5. 複雑な相互作用・レアケース

**移行条件:**

- [ ] 3-5個の仮説を立てた
- [ ] 仮説に優先順位をつけた
- [ ] 最も可能性の高い仮説を特定した

### フェーズ4: 体系的な検証

**ステップ1: 仮説を一つずつ検証**

最も優先度の高い仮説から順に検証：

1. **検証方法の決定**
   - ログ・デバッグ出力を追加
   - 最小再現コードを作成
   - デバッガでステップ実行
   - ユニットテストを作成

2. **一度に一つだけ検証**
   - 複数の仮説を同時に検証しない
   - 一つの変更で一つの仮説を検証
   - 結果を記録してから次へ

3. **証拠の収集**
   - 仮説が正しいか間違いか明確にする
   - 「たぶん」ではなく確実な証拠
   - ログ・出力・テスト結果を保存

**ステップ2: 切り分けの手法**

問題の範囲を絞り込む：

1. **二分探索的アプローチ**
   - コードの半分をコメントアウトして確認
   - 問題がある方をさらに半分に
   - 問題箇所を特定するまで繰り返す

2. **入力の単純化**
   - 複雑な入力から始めて徐々に単純化
   - どの入力で問題が起きるか特定
   - 境界値・エッジケースを試す

3. **モック・スタブの利用**
   - 外部依存をモックに置き換え
   - 問題が内部か外部か特定
   - 各コンポーネントを個別に検証

**ステップ3: デバッグツールの活用**

適切なツールを使用して効率化：

1. **デバッガ**
   - ブレークポイントで実行を止める
   - 変数の値を確認
   - ステップ実行で処理を追跡

2. **ログ**
   - 重要な箇所にログを追加
   - 変数の値を出力
   - 実行経路を確認

3. **プロファイラ**
   - パフォーマンス問題の場合
   - ボトルネックの特定
   - メモリリークの検出

**移行条件:**

- [ ] 根本原因を特定した
- [ ] なぜ問題が起きているか理解した

### フェーズ5: 修正の実装と検証

**ステップ1: 修正方針の決定**

原因が特定できたら、修正方針を決める：

1. **症状ではなく原因を修正**
   - 表面的な対処ではなく根本原因を直す
   - なぜ問題が起きたか理解してから修正

2. **最小限の変更**
   - 必要最小限の修正に留める
   - 大きなリファクタリングは別途行う
   - 一つの問題に集中

3. **他への影響を考慮**
   - 修正が他の機能に影響しないか
   - エッジケースをカバーしているか
   - 新しいバグを生まないか

**ステップ2: 修正の実装**

1. **段階的に修正**
   - 一度に全て修正しない
   - 小さな変更を加えて検証
   - 動作を確認しながら進める

2. **修正コードのレビュー**
   - 修正内容が正しいか再確認
   - コードスタイル・規約に従っているか
   - コメント・ドキュメントの更新

3. **テストの追加**
   - バグが再発しないテストを追加
   - エッジケースもカバー
   - 回帰テストを実施

**ステップ3: 修正の検証**

1. **元の問題が解決したか確認**
   - 最小再現ケースで検証
   - 元のエラーが出ないことを確認
   - 期待通りの動作になったか確認

2. **副作用がないか確認**
   - 既存のテストがパスするか
   - 関連機能が正常に動作するか
   - パフォーマンスへの影響

3. **エッジケースの確認**
   - 境界値での動作
   - Null/空データでの動作
   - 異常系のテスト

**移行条件:**

- [ ] 修正が完了した
- [ ] 元の問題が解決した
- [ ] 副作用がないことを確認した
- [ ] テストを追加した

## 判断のポイント

### 仮説の検証方法の選択

**デバッガを使うべき場合:**

- 複雑な処理の流れを追跡したい
- 変数の値の変化を見たい
- 条件分岐の挙動を確認したい

**ログを使うべき場合:**

- 本番環境の問題
- 時系列で動作を追跡したい
- デバッガが使えない環境

**最小再現コードを作るべき場合:**

- 問題箇所の特定が困難
- 外部依存が多い
- 問題の切り分けが必要

### いつユーザーに確認すべきか

以下の場合はユーザーに確認：

1. **期待動作が不明**: 何が「正しい」動作か分からない
2. **修正の影響が大きい**: 大きな変更が必要
3. **複数の修正案**: どのアプローチが望ましいか
4. **外部要因**: 環境・設定の変更が必要
5. **行き詰まり**: 3-4個の仮説を試しても解決しない

## よくある落とし穴

1. **エラーメッセージを読まない**
   - ❌ エラーを見ずに推測で修正
   - ✅ エラーメッセージを正確に読む

2. **再現せずに修正**
   - ❌ 再現できないまま「修正」
   - ✅ 必ず再現してから修正

3. **複数箇所を同時に変更**
   - ❌ いろいろ試して何が効いたか分からない
   - ✅ 一つずつ変更して検証

4. **症状への対処**
   - ❌ エラーを握りつぶす（try-catch で無視等）
   - ✅ 根本原因を特定して修正

5. **推測による修正**
   - ❌ 「たぶんこうだろう」で修正
   - ✅ 原因を確実に特定してから修正

6. **テストの省略**
   - ❌ 修正したらすぐコミット
   - ✅ 十分にテストしてから完了

7. **ランダムな変更**
   - ❌ とりあえずいろいろ試す
   - ✅ 仮説を立ててから検証

## 検証ポイント

### 問題理解の検証

- [ ] エラーメッセージの意味を理解した
- [ ] エラーの発生箇所を特定した
- [ ] 発生条件を把握した
- [ ] 再現手順を確立した

### 原因特定の検証

- [ ] 複数の仮説を立てた
- [ ] 仮説を体系的に検証した
- [ ] 根本原因を特定した
- [ ] なぜ問題が起きたか説明できる

### 修正の検証

- [ ] 元の問題が解決した
- [ ] 副作用がない
- [ ] エッジケースもカバーした
- [ ] テストを追加した
- [ ] ドキュメント・コメントを更新した

## 他スキルとの連携

### debugging → code-review

バグ修正後、根本原因が設計にある場合：

- コードレビュースキルで全体の設計を見直す
- 同様の問題が他にないか確認
- アーキテクチャの改善を検討

### debugging → refactoring

バグを直した後、コードの品質に問題がある場合：

- リファクタリングスキルで改善
- ただし、バグ修正とリファクタリングは分けて実施
- まずバグを直し、動作確認してからリファクタリング

### debugging → performance-optimization

パフォーマンス問題のデバッグの場合：

- まずこのスキルで問題を再現・特定
- その後、パフォーマンス最適化スキルで改善

### debugging → documentation

バグ修正後：

- ドキュメントスキルで注意点を文書化
- トラブルシューティングガイドに追加
- よくある問題として記録

## デバッグの効率化テクニック

### ラバーダッキング

- 問題を誰か（または何か）に説明する
- 説明する過程で問題に気づくことが多い
- ユーザーに状況を報告する時も同様の効果

### バイナリサーチ

- 問題のある範囲を半分に絞り込む
- 効率的に問題箇所を特定
- git bisect でコミット履歴を二分探索

### 差分の確認

- 動作していた時点と現在の差分を確認
- git diff で変更箇所を追跡
- 何が変わったかが問題解決の鍵

### ペアデバッグ

- 行き詰まったらユーザーに状況を共有
- 新しい視点で問題を見る
- 説明する過程で解決策が見つかることも
