---
name: "リファクタリング"
description: "既存コード改善時の思考プロセス。リファクタリング、改善、整理、クリーンアップに関する依頼に対応"
---

# リファクタリング: 既存コードの改善時の思考プロセス

## このスキルを使う場面

- コードの品質を向上させたい
- 構造を整理・重複を削除したい
- 動作を変えずに内部実装を変更したい
- 可読性・保守性を改善したい
- 技術的負債を解消したい
- コードの理解を深めながら整理したい

## 思考プロセス

### フェーズ1: 開始前の安全確認

**ステップ1: テストの確認**

リファクタリング前に必ずテストの状況を確認：

1. **既存テストの有無**
   - [ ] ユニットテストが存在するか
   - [ ] テストカバレッジは十分か
   - [ ] すべてのテストがパスするか

2. **テストがない場合**
   - まずテストを作成する
   - 最低限、主要な動作を検証するテスト
   - リファクタリング後の検証に必須

3. **テスト作成が困難な場合**
   - より小さい単位に分割してテスト
   - 入出力だけでも検証
   - 変更範囲を最小限に抑える

**ステップ2: 現状の理解**

リファクタリング対象を十分に理解する：

- [ ] コードが何をしているか理解したか
- [ ] なぜそのように実装されているか理解したか
- [ ] どこから使われているか把握したか
- [ ] 依存関係を理解したか

**ステップ3: バージョン管理の確認**

安全な作業のための準備：

- [ ] 現在の状態をコミットしたか
- [ ] ブランチは適切か
- [ ] いつでも戻せる状態か

**ステップ4: 影響範囲の評価**

変更の影響を評価：

- [ ] 変更箇所はどこか
- [ ] 影響を受ける箇所はどこか
- [ ] 外部 API への影響はないか
- [ ] データベーススキーマへの影響はないか

**移行条件:**

- [ ] テストが整っている（またはテストを作成した）
- [ ] コードを理解した
- [ ] 安全にリファクタリングできる準備が整った

### フェーズ2: リファクタリングの原則と優先順位

**リファクタリングの基本原則:**

1. **一度に一つ**: 複数の変更を同時にしない
2. **小さく刻む**: 大きな変更は小さなステップに分解
3. **常にテスト**: 各ステップでテストを実行
4. **動作を変えない**: 外部から見た動作は同じ
5. **コミット頻度**: 各ステップでコミット

**優先順位（この順で実施）:**

**1. 重複の除去**

- 同じコードが複数箇所にある
- DRY 原則の適用
- 共通処理の抽出

**2. 命名の改善**

- 分かりにくい変数名・関数名
- 意図が伝わる名前に変更
- 規約に沿った命名

**3. 長い関数の分割**

- 一つの関数が長すぎる
- 単一責任に分割
- 可読性の向上

**4. 条件式の簡潔化**

- 複雑な条件式
- ネストの深い if 文
- 早期リターンの活用

**5. データ構造の改善**

- 不適切なデータ構造
- より適切な構造に変更
- 処理の簡潔化

**6. クラス・モジュールの整理**

- 責任の再配置
- 適切な抽象化
- アーキテクチャの改善

**移行条件:**

- [ ] どのリファクタリングを行うか決定した
- [ ] 優先順位を決定した
- [ ] 最初のステップを特定した

### フェーズ3: 段階的なリファクタリングの実施

**ステップ1: 重複の除去**

**1. 重複コードの特定**

- 同一または類似のコードブロックを探す
- コピー＆ペーストした箇所を特定
- パターンを認識

**2. 共通処理の抽出**

```
手順:
1. 重複部分を特定
2. 共通部分を新しい関数に抽出
3. 元の箇所から新しい関数を呼び出す
4. テストを実行
5. コミット
```

**3. 検証**

- [ ] すべてのテストがパスする
- [ ] 動作が変わっていない
- [ ] より分かりやすくなった

**ステップ2: 命名の改善**

**1. 改善が必要な名前の特定**

以下のような名前を改善：

- 短すぎる（a, b, tmp 等）
- 意味不明（data, info 等）
- 誤解を招く（getUserData が更新もする等）
- 規約に合わない

**2. 改名の実施**

```
手順:
1. より良い名前を考える
2. IDE の rename 機能を使用（可能なら）
3. すべての参照箇所を更新
4. テストを実行
5. コミット
```

**3. 検証**

- [ ] すべての参照が更新された
- [ ] テストがパスする
- [ ] 意図が明確になった

**ステップ3: 長い関数の分割**

**1. 分割対象の特定**

以下のような関数を分割：

- 50 行以上の関数
- 複数の責任を持つ関数
- コメントで区切られている関数
- ネストが深い関数

**2. 責任の分離**

```
手順:
1. 関数が行っている処理をリストアップ
2. 各処理を別関数に抽出
3. 元の関数から新関数を呼び出す
4. テストを実行
5. コミット
```

**3. 検証**

- [ ] 各関数が単一責任
- [ ] テストがパスする
- [ ] 可読性が向上した

**ステップ4: 条件式の簡潔化**

**1. 複雑な条件式の特定**

- ネストが深い if 文
- 長い条件式
- 複雑な論理演算

**2. 簡潔化の手法**

**早期リターン:**

```python
# Before
def process(data):
    if data is not None:
        if len(data) > 0:
            # 処理
            return result
    return None

# After
def process(data):
    if data is None:
        return None
    if len(data) == 0:
        return None
    # 処理
    return result
```

**条件の抽出:**

```python
# Before
if user.age >= 18 and user.has_license and not user.is_suspended:
    allow_drive()

# After
if can_drive(user):
    allow_drive()

def can_drive(user):
    return user.age >= 18 and user.has_license and not user.is_suspended
```

**3. 検証**

- [ ] ネストが浅くなった
- [ ] 条件の意図が明確
- [ ] テストがパスする

**ステップ5: データ構造の改善**

**1. 改善が必要なデータ構造の特定**

- プリミティブ型への執着（住所を文字列で持つ等）
- 不適切なコレクション選択
- データの重複

**2. 改善の実施**

```
手順:
1. 新しいデータ構造を定義
2. 変換関数を作成（旧 → 新）
3. 段階的に新構造に移行
4. 各ステップでテスト
5. 旧構造を削除
6. コミット
```

**3. 検証**

- [ ] データの扱いが簡潔に
- [ ] 型安全性が向上
- [ ] テストがパスする

**ステップ6: クラス・モジュールの整理**

**1. 責任の再配置**

- 大きすぎるクラスを分割
- 小さすぎるクラスを統合
- 適切な抽象化レベル

**2. 実施手順**

```
手順:
1. 責任を明確に定義
2. メソッド・フィールドを適切なクラスに移動
3. インターフェースを明確に
4. 各ステップでテスト
5. コミット
```

**3. 検証**

- [ ] 各クラスの責任が明確
- [ ] 依存関係が適切
- [ ] テストがパスする

### フェーズ4: 各ステップでの動作確認

**すべてのリファクタリングステップで以下を実施:**

**1. テストの実行**

- [ ] すべてのテストがパスする
- [ ] 新しいテストを追加（必要なら）
- [ ] カバレッジが維持されている

**2. 動作確認**

- [ ] 手動でも動作確認（可能なら）
- [ ] 主要なユースケースを試す
- [ ] エラーが出ないか確認

**3. コードレビュー（自己）**

- [ ] 変更が意図通りか
- [ ] 他に影響がないか
- [ ] コーディング規約に従っているか

**4. コミット**

- [ ] 分かりやすいコミットメッセージ
- [ ] 小さな単位でコミット
- [ ] いつでも戻せる状態を維持

**危険信号 - すぐに中断すべき状況:**

- テストが失敗し始めた
- 変更範囲が想定より大きくなった
- 何を変更しているか分からなくなった
- 動作が変わってしまった

**中断時の対処:**

1. 最後の正常なコミットに戻る
2. より小さなステップに分解
3. アプローチを再考

## 判断のポイント

### リファクタリングすべきか？

**すぐにリファクタリング:**

- 明らかな重複がある
- 変数名が意味不明
- 次の作業の妨げになっている
- バグの原因になりそう

**後でリファクタリング:**

- 今触らない箇所
- 時間がない（別タスクとして）
- リスクが高い（テストがない等）

**リファクタリングしない:**

- 動作するレガシーコード（触らないなら）
- 廃止予定のコード
- 理解が不十分なコード

### どこまでリファクタリングすべきか？

**最小限:**

- 作業に必要な箇所だけ
- 明らかな問題だけ
- リスクを最小化

**徹底的:**

- 技術的負債の解消が目的
- 十分なテストがある
- 時間がある

**ボーイスカウト原則:**

- 来た時よりも少しキレイにして帰る
- 触った箇所は改善する
- ただし最小限に

## よくある落とし穴

1. **テストなしでリファクタリング**
   - ❌ テストがなくても実施
   - ✅ 先にテストを作成

2. **一度に大きく変更**
   - ❌ 大規模な変更を一気に
   - ✅ 小さく刻んで段階的に

3. **動作を変えてしまう**
   - ❌ リファクタリングで新機能追加
   - ✅ 動作は完全に同じに保つ

4. **テストのスキップ**
   - ❌ 「簡単だから」テストしない
   - ✅ 毎回必ずテスト

5. **元に戻せない**
   - ❌ コミットせずに進める
   - ✅ 小さく頻繁にコミット

6. **理解不足のまま変更**
   - ❌ コードを理解せず変更
   - ✅ 十分理解してから変更

7. **機能追加との混在**
   - ❌ リファクタリングと新機能を同時に
   - ✅ 明確に分けて実施

## 検証ポイント

### 開始前の検証

- [ ] テストが整っている
- [ ] コードを理解した
- [ ] 安全に戻せる状態
- [ ] 影響範囲を把握した

### 各ステップの検証

- [ ] すべてのテストがパスする
- [ ] 動作が変わっていない
- [ ] 改善されている（可読性等）
- [ ] コミットした

### 完了時の検証

- [ ] 目的を達成した
- [ ] すべてのテストがパスする
- [ ] 副作用がない
- [ ] ドキュメントを更新した（必要なら）

## 他スキルとの連携

### debugging → refactoring

バグ修正後にリファクタリング：

1. debugging スキルでバグを修正
2. 動作確認
3. このスキルでコードを改善
4. バグが起きにくい構造に

**重要**: バグ修正とリファクタリングは別のコミットに

### code-creation → refactoring

新機能実装後にリファクタリング：

1. code-creation スキルで実装
2. 動作確認
3. このスキルで品質改善
4. よりキレイなコードに

### refactoring → code-review

リファクタリング後のレビュー：

1. このスキルでリファクタリング
2. code-review スキルで品質確認
3. さらなる改善点の発見

### refactoring + system-design

大規模なリファクタリングの場合：

1. system-design スキルでアーキテクチャを再設計
2. このスキルで段階的に移行
3. 各段階で動作確認

## リファクタリングのカタログ

### メソッド抽出（Extract Method）

長い関数から処理を抽出して新しい関数に

### 変数名の変更（Rename Variable）

意味が明確になる名前に変更

### 条件記述の統合（Consolidate Conditional）

複数の条件を一つにまとめる

### ガード節による入れ子の条件記述の置き換え（Replace Nested Conditional with Guard Clauses）

早期リターンでネストを減らす

### ポリモーフィズムによる条件記述の置き換え（Replace Conditional with Polymorphism）

型による分岐を継承・インターフェースで置き換え

### 一時変数のインライン化（Inline Temp）

一度しか使わない変数を削除

### クラスの抽出（Extract Class）

大きすぎるクラスを分割

### メソッドの移動（Move Method）

メソッドをより適切なクラスに移動

## リファクタリングの心構え

### 完璧を求めない

- すべてをキレイにする必要はない
- 触る箇所を少し改善する
- 段階的に良くしていく

### リスクを管理する

- テストで安全網を確保
- 小さく刻んで変更
- いつでも戻せるように

### 価値を意識する

- リファクタリングは手段であって目的ではない
- ビジネス価値を生む作業とのバランス
- 本当に必要なリファクタリングを優先

### コミュニケーション

- リファクタリングの意図を説明
- なぜ必要かを明確に
- チーム・ユーザーと認識を共有
