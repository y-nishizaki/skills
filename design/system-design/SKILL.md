---
name: "システム設計"
description: "システム・アーキテクチャ設計時の思考プロセス。設計、アーキテクチャ、システム、構成に関する依頼に対応"
---

# システム設計: システム・アーキテクチャ設計時の思考プロセス

## このスキルを使う場面

- アーキテクチャの決定が必要
- コンポーネント間の関係を定義する
- 技術選択・トレードオフの検討が求められる
- 大規模な新機能の設計
- システム全体の構造を考える
- スケーラビリティ・可用性の設計

## 思考プロセス

### フェーズ1: 要件の階層的理解

**ステップ1: ビジネス要件の理解**

最上位のビジネス目的を明確にする：

**ビジネスゴール:**

- [ ] 何を実現したいのか
- [ ] 誰のための システムか
- [ ] どんな価値を提供するか
- [ ] 成功の指標は何か

**制約条件:**

- [ ] 予算の制約
- [ ] 時間の制約
- [ ] 人的リソースの制約
- [ ] 組織・プロセスの制約

**ステップ2: 機能要件の整理**

システムが提供すべき機能を明確にする：

**コア機能:**

- [ ] 必須の機能（MVP）
- [ ] 優先度の高い機能
- [ ] 将来追加する機能

**ユーザーストーリー:**

- [ ] 主要なユースケース
- [ ] ユーザーの行動フロー
- [ ] エッジケース・例外処理

**データ要件:**

- [ ] どんなデータを扱うか
- [ ] データの量・増加率
- [ ] データの関係性
- [ ] データの永続化要件

**ステップ3: 非機能要件の定義**

システムの品質特性を定義する：

**パフォーマンス:**

- [ ] レスポンスタイム（目標値）
- [ ] スループット（秒間リクエスト数等）
- [ ] 同時接続数
- [ ] データ処理量

**スケーラビリティ:**

- [ ] 初期規模
- [ ] 成長予測（1 年後、3 年後）
- [ ] ピーク時の負荷
- [ ] スケールアップ・アウトの方針

**可用性・信頼性:**

- [ ] 稼働率の目標（99.9%等）
- [ ] ダウンタイム許容度
- [ ] データ損失許容度
- [ ] 障害復旧時間（RTO/RPO）

**セキュリティ:**

- [ ] 認証・認可の要件
- [ ] データ暗号化の要件
- [ ] コンプライアンス要件
- [ ] 脅威モデル

**保守性・拡張性:**

- [ ] 変更の頻度・範囲
- [ ] 開発チームのスキル
- [ ] ドキュメント要件
- [ ] テスト要件

**移行条件:**

- [ ] ビジネス要件を理解した
- [ ] 機能要件を整理した
- [ ] 非機能要件を定義した
- [ ] 優先順位を明確にした

### フェーズ2: 設計の段階的進行

**ステップ1: 高レベル設計**

システム全体の構造を決定する：

**1. アーキテクチャスタイルの選択**

以下から適切なスタイルを選択：

- **モノリシック**: シンプル、小規模、チーム小
- **マイクロサービス**: 複雑、大規模、チーム複数
- **レイヤードアーキテクチャ**: 分離、保守性
- **イベント駆動**: 非同期、疎結合
- **サーバーレス**: スケーラビリティ、運用負荷低

**選択基準:**

- チームのサイズ・スキル
- システムの複雑さ
- スケール要件
- 変更の頻度

**詳細な比較と実装例**: 各アーキテクチャスタイルの具体的な比較とユースケースについては [examples.md](examples.md) の「アーキテクチャスタイルの比較」を参照してください。

**2. 主要コンポーネントの特定**

システムを大きなブロックに分割：

- [ ] フロントエンド
- [ ] バックエンド API
- [ ] データベース
- [ ] キャッシュ
- [ ] メッセージキュー
- [ ] 外部サービス連携

**3. データフローの設計**

データがシステムをどう流れるか：

- ユーザー → フロントエンド → API → DB
- イベント → キュー → ワーカー → DB
- データの方向性・変換

**4. システム境界の定義**

- どこまでが自システムか
- 外部システムとの境界
- 責任範囲の明確化

**ステップ2: コンポーネント分割**

各コンポーネントをさらに詳細化：

**1. 責任の割り当て**

各コンポーネントが何を担当するか：

- 単一責任の原則
- 高凝集・疎結合
- 明確な境界

**2. インターフェースの定義**

コンポーネント間の契約：

- API エンドポイント
- メッセージ形式
- データスキーマ
- エラーハンドリング

**3. 依存関係の管理**

- 依存の方向性
- 循環依存の回避
- 依存性逆転の原則

**ステップ3: データ設計**

**1. データモデルの設計**

- エンティティの特定
- リレーションシップ
- 正規化の程度
- 非正規化の判断

**2. ストレージの選択**

データの特性に応じて選択：

- **リレーショナル DB**: 構造化データ、トランザクション
- **NoSQL**: スケール、柔軟なスキーマ
- **キーバリューストア**: 高速アクセス
- **ドキュメントストア**: 柔軟なデータ
- **グラフ DB**: 関係性が重要
- **時系列 DB**: 時系列データ

**具体的な選択例**: SQL vs NoSQL の詳細な比較と選択基準については [examples.md](examples.md) の「データ設計の例」を参照してください。

**3. データアクセスパターン**

- 読み取り vs 書き込みの比率
- クエリのパターン
- インデックス戦略
- キャッシュ戦略

**移行条件:**

- [ ] アーキテクチャスタイルを決定した
- [ ] 主要コンポーネントを特定した
- [ ] コンポーネント間のインターフェースを定義した
- [ ] データ設計を完了した

### フェーズ3: 技術選択とトレードオフ

**ステップ1: 技術スタックの選択**

各層の技術を選択：

**フロントエンド:**

- フレームワーク（React, Vue, Angular 等）
- 状態管理
- UI ライブラリ

**バックエンド:**

- 言語（Python, Java, Node.js 等）
- フレームワーク
- ライブラリ

**データベース:**

- RDBMS（PostgreSQL, MySQL 等）
- NoSQL（MongoDB, DynamoDB 等）
- キャッシュ（Redis, Memcached 等）

**インフラ:**

- クラウド（AWS, GCP, Azure）
- コンテナ（Docker, Kubernetes）
- CI/CD

**選択基準:**

1. **要件への適合**: 機能・非機能要件を満たすか
2. **チームのスキル**: 習熟度・学習コスト
3. **エコシステム**: ライブラリ・ツール・コミュニティ
4. **成熟度**: 安定性・実績
5. **コスト**: ライセンス・運用コスト
6. **長期的視点**: サポート・将来性

**ステップ2: トレードオフの記録**

重要な決定とそのトレードオフを記録：

**記録すべき内容:**

1. **決定事項**: 何を選択したか
2. **理由**: なぜその選択をしたか
3. **代替案**: 他に検討した選択肢
4. **トレードオフ**: メリット・デメリット
5. **前提条件**: どんな前提での決定か
6. **再検討の条件**: どうなったら見直すか

**具体的な記録例**: トレードオフ記録の詳細なテンプレートと実例については [examples.md](examples.md) の「トレードオフの記録例」を参照してください。

**ステップ3: スケーラビリティの設計**

**1. 垂直スケール（スケールアップ）**

- より大きなサーバーに移行
- シンプル
- 上限がある

**2. 水平スケール（スケールアウト）**

- サーバー台数を増やす
- 無限にスケール可能（理論上）
- 複雑さ増加

**スケール戦略:**

- **ステートレス化**: サーバーに状態を持たない
- **ロードバランシング**: 負荷分散
- **データベースシャーディング**: データ分割
- **読み取りレプリカ**: 読み取り負荷分散
- **キャッシュ**: データベース負荷軽減
- **非同期処理**: 即座の応答不要な処理を分離

**詳細なパターンと実装**: 各スケール戦略の具体的な実装パターンと構成図については [examples.md](examples.md) の「スケーラビリティパターン」を参照してください。

**移行条件:**

- [ ] 技術スタックを決定した
- [ ] 主要なトレードオフを記録した
- [ ] スケーラビリティ戦略を定義した

### フェーズ4: 信頼性とセキュリティの設計

**ステップ1: 障害対策**

**単一障害点（SPOF）の排除:**

- [ ] すべてのコンポーネントを冗長化
- [ ] ロードバランサーの冗長化
- [ ] データベースのレプリケーション
- [ ] 複数 AZ/リージョンの活用

**障害検出:**

- ヘルスチェック
- モニタリング・アラート
- ログ集約
- 分散トレーシング

**障害復旧:**

- 自動フェイルオーバー
- サーキットブレーカー
- リトライ・タイムアウト
- グレースフルデグラデーション

**具体的な実装パターン**: サーキットブレーカー、リトライ戦略、バルクヘッドパターンの実装例については [examples.md](examples.md) の「信頼性パターン」を参照してください。

**ステップ2: データの信頼性**

**バックアップ:**

- [ ] バックアップの頻度
- [ ] バックアップの保存期間
- [ ] バックアップからのリストア手順
- [ ] リストアのテスト

**レプリケーション:**

- 同期 vs 非同期
- マスター・スレーブ vs マルチマスター
- リージョン間レプリケーション

**整合性:**

- 強整合性 vs 結果整合性
- ACID vs BASE
- CAP 定理の理解とトレードオフ

**ステップ3: セキュリティ設計**

**認証・認可:**

- [ ] 認証方式（OAuth, JWT 等）
- [ ] ロールベースアクセス制御
- [ ] API キー管理
- [ ] セッション管理

**データ保護:**

- [ ] 転送中の暗号化（TLS/SSL）
- [ ] 保存時の暗号化
- [ ] 機密情報の管理（パスワード、API キー）
- [ ] PII の保護

**ネットワークセキュリティ:**

- [ ] ファイアウォール
- [ ] VPC/サブネット設計
- [ ] DDoS 対策
- [ ] WAF（Web Application Firewall）

**アプリケーションセキュリティ:**

- [ ] 入力検証
- [ ] SQL インジェクション対策
- [ ] XSS 対策
- [ ] CSRF 対策

**移行条件:**

- [ ] 障害対策を設計した
- [ ] データの信頼性を確保した
- [ ] セキュリティ要件を満たした

### フェーズ5: 設計の文書化と検証

**ステップ1: アーキテクチャ文書の作成**

**含めるべき内容:**

1. **概要**
   - システムの目的
   - 主要な機能
   - ユーザー・ステークホルダー

2. **アーキテクチャ図**
   - システム全体図
   - コンポーネント図
   - データフロー図
   - デプロイ図

3. **コンポーネント詳細**
   - 各コンポーネントの責任
   - インターフェース仕様
   - 依存関係

4. **技術選択**
   - 選択した技術とその理由
   - トレードオフ
   - 代替案

5. **非機能要件への対応**
   - パフォーマンス戦略
   - スケーラビリティ設計
   - 可用性・信頼性設計
   - セキュリティ設計

6. **運用考慮事項**
   - デプロイ方法
   - モニタリング・ロギング
   - バックアップ・リカバリ
   - スケーリング手順

**ステップ2: 設計のレビュー**

**レビューの観点:**

1. **要件充足性**
   - [ ] すべての機能要件を満たすか
   - [ ] 非機能要件を満たすか
   - [ ] エッジケースをカバーしているか

2. **実現可能性**
   - [ ] 技術的に実現可能か
   - [ ] チームのスキルで実装可能か
   - [ ] 予算・期間内に収まるか

3. **保守性**
   - [ ] 理解しやすいか
   - [ ] 変更しやすいか
   - [ ] テストしやすいか

4. **スケーラビリティ**
   - [ ] 将来の成長に対応できるか
   - [ ] ボトルネックはないか
   - [ ] スケール戦略は明確か

**ステップ3: プロトタイプ・PoC**

不確実性が高い場合：

- 技術的検証が必要な部分
- パフォーマンス検証
- 統合検証
- ユーザー体験の検証

**移行条件:**

- [ ] 設計を文書化した
- [ ] レビューを完了した
- [ ] 不確実性を解消した

## 判断のポイント

### どれくらい設計すべきか

**詳細設計が必要:**

- 大規模システム
- 複雑な要件
- 複数チームでの開発
- クリティカルなシステム

**最小限の設計で十分:**

- 小規模システム
- シンプルな要件
- 少人数チーム
- プロトタイプ・MVP

**反復的設計:**

- 要件が流動的
- アジャイル開発
- 学習しながら改善

### いつ設計を見直すべきか

**すぐに見直し:**

- 要件が大きく変わった
- パフォーマンス問題が深刻
- スケールの限界に達した
- セキュリティ問題が発覚

**計画的な見直し:**

- 定期的なアーキテクチャレビュー
- 技術的負債の解消
- 技術スタックの更新

## よくある落とし穴

1. **過剰設計**
   - ❌ 将来を見越して複雑に
   - ✅ シンプルに始めて必要に応じて拡張

2. **要件理解不足**
   - ❌ 曖昧なまま設計開始
   - ✅ 要件を十分に理解してから

3. **非機能要件の軽視**
   - ❌ 機能だけ考える
   - ✅ パフォーマンス等も重視

4. **既存技術への固執**
   - ❌ 慣れた技術だけ使う
   - ✅ 要件に最適な技術を選ぶ

5. **SPOF の放置**
   - ❌ 単一障害点を残す
   - ✅ 冗長化を検討

6. **セキュリティの後回し**
   - ❌ 後で考える
   - ✅ 最初から組み込む

7. **ドキュメント不足**
   - ❌ 頭の中だけ
   - ✅ 適切に文書化

## 検証ポイント

### 要件の検証

- [ ] ビジネス要件を理解した
- [ ] 機能要件を整理した
- [ ] 非機能要件を定義した
- [ ] 制約条件を把握した

### 設計の検証

- [ ] アーキテクチャスタイルを選択した
- [ ] コンポーネントを適切に分割した
- [ ] インターフェースを定義した
- [ ] データ設計を完了した

### 技術の検証

- [ ] 技術スタックを選択した
- [ ] トレードオフを記録した
- [ ] スケール戦略を定義した
- [ ] 信頼性・セキュリティを考慮した

### 文書化の検証

- [ ] アーキテクチャ文書を作成した
- [ ] 図で視覚的に表現した
- [ ] 決定事項と理由を記録した
- [ ] レビューを完了した

## 他スキルとの連携

### system-design → code-creation

設計から実装へ：

1. このスキルで設計を完了
2. code-creation スキルで実装
3. 設計に従った実装を確保

### system-design → code-review

設計のレビュー：

1. このスキルで設計案を作成
2. code-review スキルでレビュー
3. フィードバックを反映

### system-design → performance-optimization

パフォーマンス考慮設計：

1. このスキルでパフォーマンス要件を設計
2. performance-optimization スキルで検証
3. 必要に応じて設計を調整

### system-design → documentation

設計の文書化：

1. このスキルで設計（簡易ドキュメント含む）
2. documentation スキルで詳細文書化
3. アーキテクチャドキュメントの作成

## 設計原則

### SOLID 原則

- **S**: 単一責任の原則
- **O**: 開放閉鎖の原則
- **L**: リスコフの置換原則
- **I**: インターフェース分離の原則
- **D**: 依存性逆転の原則

### DRY（Don't Repeat Yourself）

- 重複を避ける
- 共通化・抽象化

### KISS（Keep It Simple, Stupid）

- シンプルに保つ
- 複雑さは敵

### YAGNI（You Aren't Gonna Need It）

- 今必要ないものは作らない
- 過剰設計を避ける

### 関心の分離

- 異なる関心事を分離
- 独立性を高める
